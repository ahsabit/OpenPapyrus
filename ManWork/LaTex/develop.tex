% DEVELOP.TEX
% Copyright (c) A.Sobolev 2010, 2011, 2012, 2014, 2015, 2019, 2020, 2023
% Part of project Papyrus
% Разработка программной системы: принципы и реализация %
%
\documentclass[nobib]{papyrus}
\usepackage{index}
\makeindex
%\usepackage{makeidx}
%
% Титульный лист {
%
\usepackage{CoverPage}
\usepackage{listings}
\usepackage{xcolor}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
	tabsize=4
}

\CoverPageSetup{
	title={Разработка системы Papyrus: принципы и реализация},
	author={},
	copyright={\copyright Петроглиф},
	institute={},
	insource={}
}

\renewcommand{\CoverPageFooterInfo}{
	\parbox[b]{.5\textwidth}{
		\tiny Документ создан: \today
    }
}

\renewcommand{\CoverPageHeader}{}%{\includegraphics[width=\textwidth]{\ppy\ctpath/BrushedMetal}}
\renewcommand{\CoverPageFooterLogo}{}%\includegraphics[scale=0.4]{\ppypictpath/petroglif}}

\begin{document}

\chapter{Введение}

Настоящий документ описывает (часто в беспорядочном виде) внутреннее устройство системы Papyurs 
и инфраструктуры этой системы. 

Так как система Papyrus представлена одновременно в проприетарном виде (собственно, Papyrus) так 
и в виде системы с открытыми исходными кодами OpenPapyrus, то в дальнейшем все ссылки на Papyrus 
в равной степени можно трактовать и как OpenPapyrus. Тем более, что эти две сущности имеют мизерные
различия и развиваются параллельно.

Документ предназначен, главным образом, для разработчиков.

\chapter{Инструментарий}

В этой главе рассмотрены инструментальные средства разработки и сборки системы.

\section{Языки программирования}
Подавляющая часть проекта реализована на языке c++.

\subsubsection{Стандарт языка c++}
В проекте применяется подмножество языка c++, соответствующее стандарту ISO/IEC 14882:1998. Возможности, доступные
в более поздних стандартах практически не используются.

\section{Компилятор и среда разработки}

Для работы собственно над ядром системы используется среда разработки Microsoft Visual Studio.
В состав исходных кодов входят каталоги, содержащие файлы решений (solution) и проектов (project) для
Visual Studio версий 7.10 (Visual Studio 2003), и 15.0 (Visual Studio 2017).

Проект одинаково успешно компилируется в каждой из указанных версий среды.

\ppynote{ Дистрибутивы релизов собираются на Visual Studio 2017 и Visual Studio 7.10. 
	Основной дистрибутив релизов собирается на Visual Studio 2017. На Visual Studio 7.10
	собираются дополнительные модули с суффиксом -xp, обеспечивающие работу системы
	на операционных системах Windows XP и Windows Server 2003.
	
	Официально, с 2021 года поддержка Windows XP и Windows Server 2003 прекращается (хотя,
	дистрибутивы по-прежнему содержат упомянутые модули).
	
	Начиная с начала 2023 года сборка средствами Visual Studio 7.10 прекращена. Так же полностью
	остановлена поддержка Windows XP  и Windows Server 2003.
}

\subsection{Опции компиляции и компоновки}

\subsubsection{Конфигурации решения (Solution Configurations)}

Решение содержит 6 конфигураций для трех базовых вариантов сборки:

\begin{itemize}
		\item Пользовательский интерактивный модуль. Файл результата: ppw.exe.
		\item Job-Server. Файл результата: ppws.exe. Запускается в виде системной службы.
		\item Dll-модуль для использования внешними компонентами. Файл результата: ppwmt.dll.
\end{itemize}


\begin{description}
	\item[Debug] Конфигурация пользовательской интерактивной сборки с отладочной информацией.
	\item[Release] Конфигурация пользовательской интерактивной сборки в релиз-варианте.
	\item[ServerDebug] Конфигурация Job-Server'а с отладочной информацией.
	\item[ServerRelease] Конфигурация Job-Server'а в релиз-варианте.
	\item[MtDllDebug] Конфигурация dll-модуля для использования внешними компонентами посредством COM-интерфейсов. С отладочной информацией.
	\item[MtDllRelease] Конфигурация dll-модуля для использования внешними компонентами посредством COM-интерфейсов. Релиз-вариант.
\end{description}

\subsubsection{Каталоги для формирования промежуточных результатов сборки (Output и Intermediate directories)}

Головной каталог проекта обычно называется Papyrus, однако это может быть и любое иное имя, например OpenPapyrus.

\begin{description}
	\item[Visual Studio 2003]
		\tiny{\textdollar(ProjectDir)../../\_\_TEMP\_\_/VC70/\textdollar(ConfigurationName)/\textdollar(ProjectName)/}
	\item[Visual Studio 2017]
		\tiny{\textdollar(ProjectDir)../../\_\_TEMP\_\_/VC2017/\textdollar(PlatformShortName)/\textdollar(Configuration)/\textdollar(ProjectName)/}
	\item[Visual Studio 2019]
		\tiny{\textdollar(ProjectDir)../../\_\_TEMP\_\_/VC2019/\textdollar(PlatformShortName)/\textdollar(Configuration)/\textdollar(ProjectName)/}
	\item[Visual Studio 2022]
		\tiny{\textdollar(ProjectDir)../../\_\_TEMP\_\_/VC2022/\textdollar(PlatformShortName)/\textdollar(Configuration)/\textdollar(ProjectName)/}
\end{description}

Обратите внимание, в шаблоне путей для Visual Studio 2017, 2019, 2022 включены дополнительные подкаталоги
для символа платформы.

Такие шаблоны применяются ко всем проектам решения.

\subsubsection{Выравнивание структур данных (struct member alignment)}
Все проекты компилируются с отсутствием выравнивания структур данных (struct member alignment = 1 byte).
Причиной для этого является потенциальная опасность несогласованности persistent-структур при сохранении или 
передачи их в потоках данных.

При этом поля структур настоятельно рекомендуется выравнивать в ручную по границе 4 байт.

Например:

\begin{lstlisting}
	// С этой структурой все в порядке: каждый элемент 
	// занимает пространство кратное 4.
	struct ABC {
		int   A;
		uint8 B[16];
		int   C;
	};
	
	// В этой структуре элемент B следует выровнять до 4-байтовой границы 
	// фиктивным элементом (в данном случае это uint8 Reserve[3]). 
	// К таким фиктивным элементам следует добавлять предопределенный 
	// комментарий @alignment.
	struct ABC2 {
		int   A;
		bool  B;
		uint8 Reserve[3]; // @alignment
		int   C;
	};	
\end{lstlisting}

\subsubsection{Character Set}
Все проекты решения компилируются в режиме Unicode.

\subsubsection{Многопоточность}
Все проекты компилируются в многопоточном варианте.

\subsubsection{Run-time библиотеки}
При сборке всех модулей применяется статическая компоновка с run-time библиотеками (multithread-вариант).

\subsubsection{Precompiled headers}
Практически все проекты сборки используют предкомпиляцию заголовков. В роли инициирующего файла обычно
выступает файл с именем aaa-pch.c(cpp) где aaa - краткая аббревиатура проекта. Например pp-pch.cpp для 
проекта Papyrus, slib-pch.cpp для проекта SLib, openssl-ssl-pch.cpp для одного из проектов openssl и так далее.

\subsubsection{Conformance mode}
Для большинства проектов решения эта опция включена. К сожалению, не все модули удается скомпилировать с этой опцией,
но мы стремимся к тому, чтоб сборка в \quad{Conformance mode} была повсеместной.

\section{Сторонние компоненты}

Мы инкорпорировали в общую инфраструктуру значительное число библиотек и компонентов сторонних разработчиков.
Не все из них используются - некоторые были адаптированы с той или иной целью, но дальнейшее применение
было отложено. Все инкорпорированные проекты подвергаются значительной адаптации таким образом, чтобы
стать максимально унифицированными со остальными частями проекта. 

Далее перечисляются почти все компоненты, которые так или иначе были включены в общую инфраструктуру.

\begin{description}
	\item[asmlib of Agner Fog] Великолепный набор ассемблерных процедур для улучшения производительности.
	
	https://www.agner.org
	\item[zlib] Версия 1.2.11. Библиотека сжатия данных. Король opensource-мира: очень многие библиотеки
	и система, как открытые, так и проприетарные, используют этот компонент.
	
	https://zlib.net
	\item[cairo] Версия 1.16.0. Библиотека векторной 2D-графики. 
	
	https://www.cairographics.org
	\item[pixman] Версия 0.36.0. Низкоуровневая поддержка для cairo.
	\item[freetype] Версия 2.10.4 (ноябрь 2020)
	
	Библиотека для работы со шрифтами. Инкорпорирована для реализации функций пользовательского интерфейса
	и отчетной подсистемы. Многие opensource-компоненты зависят от этой подсистемы.
	
	\item[HarfBuzz] Версия 2.7.2 (декабрь 2020)
	
	Библиотека для рендеринга текстов. Инкорпорирована для реализации функций пользовательского интерфейса
	и отчетной подсистемы.
	
	\item[libjpeg]
	
	Библиотека для чтения и записи изображений в формате jpeg. Используется соответствующим образом. Кроме
	того, значительное число иных компонентов зависят от этой библиотеки.
	
	\item[libjpeg-turbo]
	
	Библиотека того же назначения, что и libjpeg, но декларирующая лучшую производительность за счет
	использования SSE-команд процессора.
	Инкорпорирована в экспериментальных целях. При попытке реального использования стала вызывать 
	аварийные сбои в работе системы, из-за чего применение отключено.
	
	\item[libpng]
	
	Библиотека для чтения и записи изображений в формате png. Для этого и используется. Кроме
	того, обеспечивает зависимости других компонентов.
		
	\item[giflib]
	
	Библиотека для чтения и записи изображений в формате gif. 
	
	\item[tiff] Версия 4.0.9.
	
	Библиотека для чтения и записи изображений в формате tiff. 
	
	\item[OpenJPEG] Версия 2.3.1 (декабрь 2020)
	
	Библиотека для чтения и записи изображений в формате jpeg2000. Инкорпорирована ради
	обеспечения зависимостей других компонентов.
	
	\item[jbig2dec] Версия 0.19 (декабрь 2020)
	
	Компонент для декодирования формата сжатия изображений JBIG2. Включена для покрытия зависимостей
	других подсистем.
	
	https://jbig2dec.com
	\item[lcms2] Версия 2.11 (декабрь 2020)
	
	Little color management system. Компонент, реализующий трансформацию цветовых схем. Инкорпорирована	ради зависимостей других подсистем.
	
	https://www.littlecms.com
	\item[libxml] Версия 2.9.2. 
	
	Библиотека для чтения и записи данных в xml-формате. Интенсивно используется.
	
	Значительно переработана - дальнейшие заимствования не предполагаются.
	
	\item[BerkeleyDB]
	\item[gSOAP] Версия 2.8.8. Значительно переработана - дальнейшие заимствования не предполагаются.
	\item[Scintilla] Версия 3.7.3. Используется для редактирования текстовых файлов и вывода в окне сообщений.
	\item[cURL] Версия 7.73.
	\item[libzip]
	\item[openssl] Версия 1.1.1d.
	
	Исключительно популярная библиотека, обеспечивающая шифрование TCP/IP-соединений (TLS/SSL).
	Используется значительным числом компонентов системы.
	
	\item[libssh2]
		
	\item[nginx] Версия 1.13.4. 
	
	Нетипичный вариант интеграции. Nginx - нисколько не библиотека и не предназначен для использования 
	в таком качестве. Тем не менее, мы инкорпорировали эту систему как статическую библиотеку. Цель (не достигнутая
	до сих пор) - реализовать полноценных web-сервер, интегрирующий управления контентом с данными ERP/CRM. 
	
	\item[pcre]	Библиотека для работы с регулярными выражениями с синтаксисом perl. Интегрирована из-за
	зависимости от нее пакета Nginx.
	
	\item[7zip]	
	\item[lua] Версия 5.3.4. В планах задействовать LUA в качестве внутреннего скриптового языка.
	\item[libarchive] Версия 3.5.0 (декабрь 2020)
	\item[jansson] Экспериментальный форк, сделанный ради сборки проекта rehex.
	\item[capstone]  Версия 4.0.2 (git clone 2020-11-18). Экспериментальный форк, сделанный ради
	сборки проекта rehex.
	\item[sqlite] Версия 3.34.00. В отличии от большинства иных заимствованных проектов, эта библиотека
	пока не подвергалась рефакторингу.
	\item[mariadb-connector-c] 
	\item[abseil] Библиотека c++ общего назначения от google.
	\item[googletest]
	\item[icu]
	\item[imgui]
	\item[libphonenumber]
	\item[lz4]
	\item[zstd]
	\item[xapian]
	\item[protobuf]	
\end{description}

\chapter{Сборка проекта}

Если рассматривать процесс сборки \qu{с нуля}, то он состоит из следующих шагов:
\begin{itemize}
	\item Импортировать исходные коды из репозитория в головной каталог PAPYRUS (на любом дисковом устройстве)
	\item Установить последнюю версию Papyrus в подкаталог PAPYRUS/PPY
	\item Открыть решение Visual Studio papyrus.sln в подкаталоге PAPYRUS/SRC/BUILDVC2017 или 
	PAPYRUS/SRC/BUILDVC2019 или PAPYRUS/SRC/BUILDVC2022
	для Visual Studio 2017 или Visual Studio 2019 или Visual Studio 2022 соответственно
	\item Запустить полную сборку решения.
\end{itemize}

К сожалению, в деталях существует значительное число сложностей. Я попытаюсь часть из них рассмотреть в этой главе.

\section{Репозитории исходных кодов}

Существует 2 параллельные версии Papyrus: 
\begin{itemize}
\item собственно, проприетарная система Papyrus, исходные коды которой находятся в
приватном репозитории subversion (http://uhtt.ru:1911/svn/papyrus). 

Доступ к этому репозиторию вы можете получить
только лишь в случае, если являетесь сотрудником, вовлеченным в процесс разработки системы.

\item OpenPapyrus, которая является почти полной репликой проприетарной версии системы с очень небольшими
модификациями, касающимися ключей шифрования. Репозиторий OpenPapyrus находится по адресу 
https://github.com/papyrussolution/OpenPapyrus.git.

Доступ к этому репозиторию открыт для всех желающих изучить коды системы или включиться в совместную разработку.
\end{itemize}

\section{Инструменты сборки}
Кроме компилятора и линковщика для сборки используется значительно число иных инструментов как собственной разработки, так
и сторонних.

\chapter{Code style}

В этой главе определены правила оформления исходных кодов в проекте Papyrus.

\section{Предопределенные комментарии}
Для того, чтобы унифицировать формальные комментарии, мы сформулировали список наиболее употребительных
и разместили его в заголовке файла pp.ini.

\section{Общие правила}

\subsection{Заголовки файлов исходных кодов}

Правила описания заголовка исходного файла базируются на простом принципе: меньше-лучше.
Итак:
\begin{itemize}
	\item Первая строка - наименование файла прописными буквами без пути. Например SOMEMODULE.CPP.
	\item Вторая строка - информация об авторстве и годы модификаций. Чаще всего это что-то вроде:
	Текст \qu{Copyright (c)}, который встречается во многих файлах проекта - дань традиции. 
	Можно написать так, а можно, например, Author. Но авторство важно. 
	\item Третья строка - определение кодировки файла с префиксом @codepage. Общее правило - файлы исходных кодов должны быть в кодировке
	UTF-8. Варианты возможны, но очень не желательны. 
	\item Четвертая строка - очень краткое (буквально в несколько слов) описание того, что в файле.
\end{itemize}

Пример:
\begin{lstlisting}
// C_ATURN.CPP
// Copyright (c) A.Sobolev 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2016, 2019
// @codepage UTF-8
// Процедуры корректировки бухгалтерских проводок
//
\end{lstlisting}

Пожалуйста, не украшайте заголовок всякими безвкусными звездочками, длинными линиями из дефисов, знаков
'=' и прочей ерунды - помните что чем файл короче тем проще с ним работать.
И не надо вносить в исходные коды тексты лицензий и подробные описания ваших взглядов на жизнь.

\subsection{Макросы, предотвращающие повторное включение заголовочных файлов (include guard)}
Когда проект запускался директивы \#pragma once не было. Потому до сих пор мы используем древнюю технику
include guard с помощью макросов \#ifndef-\#define-\#endif.
Макроопределение формируется по следующему правилу: два подчеркивания, имя файла заглавными буквами, подчеркивание, 
символ H.
Пример для файла slib.h:
\begin{lstlisting}
#ifndef __SLIB_H // {
#define __SLIB_H
// ... file-body
#endif // } __SLIB_H
\end{lstlisting}

\subsection{Директивы препроцессора C/C++}

Отступы в директивах препроцессора должны предшествовать символу \#, но не разделять этот символ с директивой.

\begin{lstlisting}
	// Правильные отступы
	#if defined(A)
		#define B
	#else
		#define C
	#endif
\end{lstlisting}

\begin{lstlisting}
	// Неправильные отступы
	#if defined(A)
	#	define B
	#else
	#	define C
	#endif
\end{lstlisting}

Основной аргумент в защиту указанного правила заключается в том, что директиву
препроцессора, отделенную от символа \#, сложно искать по выборке исходных файлов.

\subsection{Примеры кода}

\subsubsection{Декларация класса}
\begin{lstlisting}
    //
    // Descr: Комментарий к классу (первая строка)
    //   продолжение комментария к классу на следующей строки с отступом в 2 пробела.
    //
    class Cls : public BaseCls {
    public:
    	Cls();
    	int    MemberFunc01(long * pID, const void * pData, size_t dataLen);
    	int    MemberFunc02(long id);
    	const void * MemberFunc03(long id, size_t * pDataLen) const;
    private:
    	virtual void VirtualMemberFunc04(void * pItem);
    
    	long   LastId;
    };
\end{lstlisting}	

Этот пример демонстрирует следующие особенности: 
\begin{itemize}
	\item Наименования классов и структур начинается с прописной буквы
	\item Наименования членов классов и структур так же начинаются с прописных букв
	\item Открывающая скобка \{ для декларации находится на той же строке, что и наименование декларации
	\item Ключевые слова public, private, protected для членов класса стартуют с той же позиции строки,
что и ключевое слово class (struct, union, enum).
\end{itemize}

\subsubsection{Определение функции (не ищите в ней смысл - это просто пример оформления текста)}

\begin{lstlisting}
    int Foo(int paramA, double paramB, const void * pParamC, char * pParamD, WierdObject & rObj)
    {
        int   ok = 1;
        int   local_var1 = 0;
        double local_var2 = 0.0; // простые типы крайне рекомендуется инициализировать при объявлении
        SomeObject * p_temp_obj = 0; // Указатель ОБЯЗАТЕЛЬНО инициализируется
        WierdObject & r_wobj = rObj;
        if(paramA > 0) {
            p_temp_obj = new SomeObject(pParamC);
            if(!p_temp_obj)
                ok = 0;
        }
        if(ok) {
            if(pParamD) {
                for(uint i = 0; i < 100; i++) {
                    local_var2 += 0.002;
                    pParamD[i] = (char)(local_var2 * 1.9);
                }
            }
            while(local_var2 > 0.0) {
                local_var2 -= 0.001;
            }
        }
        if(p_temp_obj && local_var1) do {
            p_temp_obj->Method(--local_var1);
        } while(local_var1 > 0);
        delete p_temp_obj; // Перед вызовами delete и free указатель никогда не проверяется на !0
        return ok;
    }
\end{lstlisting}

Обратите внимание на следующие особенности:
\begin{itemize}
	\item Наименования аргументов функции: начинаются со строчной буквы, слова отделяются переходом от строчной 
	к прописной букве. Аргументы-указатели всегда начинаются со строчной p (pParamC). 
	Аргументы-ссылки всегда начинаются со строчной r (rObj).
	\item Наименования локальных переменных: полностью состоят из строчных символов, слова разделяются 
	подчеркиванием \_ (local\_var1). Локальные переменные указатели всегда начинаются с p\_ (p\_temp\_obj). 
	Локальные переменные-ссылки всегда начинаются с r\_ (r\_wobj).
	\item В теле функции открывающие фигурные скобки всегда стоят в той же строке, что и оператор, требующий 
	обрамления области его действия. Закрывающая фигурная скобка - всегда на отдельной строке.
\end{itemize}

\subsubsection{Редуцированное определение функции}
В случае, если функция является тривиальной (умещается в одну строку) допускаются следующие варианты
определения таких функций:

\begin{lstlisting}
	int TrivialFunction01(double a) { return static_cast<int>(a * 100.0); }
\end{lstlisting}

\begin{lstlisting}
	int TrivialFunction_With_Rather_Long_Declaration_02(double a) 
		{ return static_cast<int>(a / 2.0); }
\end{lstlisting}

Первый вариант предпочтительнее, но, если определение вместе с декларацией занимает 
неприемлемо много места, то возможен второй вариант. Если оба варианта неприемлемы, то - возвращаемся к
штатному определению описанному выше.

\subsection{Отступы}
Для отступов в тексте кодов применяется символ табуляции. Кроме как в начале строки символы табуляции не 
должны нигде более использоваться (разделение между токенами внутри строки - только пробелы). 

\subsection{Декларации}

Настоятельно рекомендуется размещать каждую декларируемую переменную отдельным оператором.

\begin{lstlisting}	
    int    a = 6; // Правильно
    int    b = 0; // Правильно
	
    struct SomeStruc {
        int   A;   // Правильно 
        int * P_B; // Правильно
    };		
\end{lstlisting}			

\begin{lstlisting}	
    int    a = 6, b = 0; // Не желательно

    struct SomeStruc {
        int   A, * P_B; // Не правильно
    };	
\end{lstlisting}			

Причиной такой рекомендации является слабая наглядность совмещенных в одном операторе декларируемых
переменных. Кроме того, если типы переменных имеют квалификаторы указателя или ссылки, то совмещение
в одном операторе декларации вносит дополнительную путаницу.

Деклараций неинициализированных локальных переменных следует избегать. Любая неинициализированная переменная 
несет риск непредсказуемого поведения кода.

Пожалуйста, не разделяйте декларацию локальной переменной и ее инициализацию, если это возможно!
То есть, вместо:
\begin{lstlisting}	
	int    a;
	a = 100;
\end{lstlisting}	
Всегда пишите:
\begin{lstlisting}	
	int    a = 100;
\end{lstlisting}

Во-первых, зачем нужна еще одна строчка?

Во-вторых, декларацию, совмещенная с инициализацией проще объявить константной (если возможно).

В-третьих, будет намного проще разбираться с кодом.

\subsection{Квалификатор const}

Если какая-то переменная, локальная или глобальная, равно как и член класса/структуры а также функция-член
класса, может быть объявлена с квалификатором const, то это обязательно следует сделать. Несмотря на все 
его недостатки, const позволяет усилить надежность кода и облегчить его поддержку.

Особое внимание следует уделить аргументам функций, передаваемых по ссылке либо по указателю. Если объект, на
который ссылается указатель или ссылка не будет и, тем более, не должен меняться функцией, то аргумент следует
декларировать с квалификатором const. Это важно для обеспечения неизменяемости объектов на большой глубине вызовов.

Например:
\begin{lstlisting}	
	struct SomeBlock {
		SomeBlock(int a, double b) : A(a), B(b)
		{
		}
		int    A;
		double B;
	};
	//
	// 
	// Не правильно: в этой функции аргумент pSb может быть объявлен как const
	//
	double Foo_Wrong(SomeBlock * pSb) 
	{
		return pSb ? (pSb->A * pSb->B) : 0.0;
	}
	//
	// 
	// Правильно: в этой функции аргумент pSb объявлен как const. 
	// Теперь мы можем надеяться что после вызова функции ничего с 
	// нашим объектом не случилось.
	//
	double Foo_Right(const SomeBlock * pSb) 
	{
		return pSb ? (pSb->A * pSb->B) : 0.0;
	}
	//
	// 
	// В этой функции мы инициализируем константный объект SomeBlock 
	// и вызовем Foo_Right(const SomeBlock *)
	//
	double FooCaller()
	{
		const SomeBlock sb(20, 0.744);
		// Компилятор не позволит нам вместо Foo_Right() вызвать Foo_Wrong()
		// поскольку мы инициализировали sb как константный экземпляр SomeBlock.
		return Foo_Right(&sb);
	}
\end{lstlisting}

\subsubsection{Важное замечание относительно const}
Хотя я, как мог, обстоятельно рассмотрел необходимость использования модификатора const
следует понимать, что во многих случаях это - декоративный элемент синтаксиса. Твердой гарантии
неизменяемости объекта он не дает. Это связано во-первых, с возможность программиста преобразованием
типов отменить const, а, во-вторых, что особенно печально, с отсутствием гарантии со стороны
компилятора на соблюдение константности таких объектов.

\subsection{Операторы}

\subsubsection{Оператор if}

\begin{lstlisting}	
        if(paramA > 0) {
            p_temp_obj = new SomeObject(pParamC);
        }
\end{lstlisting}			

Между ключевым словом if и открывающей скобкой пробела нет. Если оператор сложный (в фигурных скобках), то
открывающая фигурная скобка находится в той же строке, что и if (один пробел после закрывающей круглой скобки).
В большинстве случаев настоятельно рекомендуется обрамлять тело, исполняемое при истинном значении условия,
фигурными скобками даже если их можно опустить (простой единичный оператор или вложенный условный оператор либо цикл).

\begin{lstlisting}	
        if(paramA > 0) {
            for(uint idx = 0; idx < count; idx++) {
                ;
            }
        }
\end{lstlisting}			

\subsubsection{Конструкция if else}

\begin{lstlisting}	
        if(paramA > 0) {
            p_temp_obj = new SomeObject(pParamC);
        }
        else {
            p_temp_obj = 0;
        }
\end{lstlisting}			

\subsubsection{Конструкция if do while}

\begin{lstlisting}	
        if(c) do {
            foo(--c);
        } while(c);
\end{lstlisting}			

Тот случай, когда простая вложенная в if конструкция не обрамляется фигурными скобками, и, более того, 
тело if начинается на той же строке (это действительно исключение: никогда иначе не ставьте оператор, 
выполняемый в случае if на той же строке - вносит путаницу при чтении кода).

\begin{lstlisting}	
        if(paramA > 0) p_temp_obj = new SomeObject(pParamC); // ТАК НЕЛЬЗЯ
\end{lstlisting}			

\subsubsection{Конструкция switch case}

\begin{lstlisting}	
    switch(tag) {
        case tagconst1:
            SomethingToDo1();
            break;
        case tagconst2:
            SomethingToDo2();
            break;		
        case tagconst3:
            // @fallthrough
        case tagconst4:
            {
                SomeClass some_class_instance;
                some_class_instance.foo();
            }
            break;
        default:
            break;
    }
\end{lstlisting}			

В приведенном примере видны следующие особенности:
\begin{itemize}
	\item Открывающая фигурная скобка оператора switch() находится на той же строке (аналогично if, for, do, while).
	\item Операторы case находятся на расстоянии одинарного отступа от switch.
	\item Исполняемый код, относящийся к case отстоит от самого case на дистанции одинарного отступа.
	\item break всегда находится на одинарном отступе от case
	\item Если исполняемый код, относящийся к case требует заключения в фигурные скобки (по причине использования
	  локальный по отношению к нему переменных), то этот код размещается еще на величину одного отступа от фигурных
	  скобок, которые, в свою очередь, расположены на расстоянии единичного отступа от case.
	  В соответствии с предыдущим правилом, общий break в этом случае размещен ниже закрывающей скобки и на том
	  же уровне.
	  Описанная позиция break важна для того, чтобы было видно, что он присутствует.
	\item Если break в case отсутствует по умыслу программиста, то на его месте необходимо разместить 
	  предопределенный комментарий 
		\begin{lstlisting}			
			// @fallthrough
		\end{lstlisting}	
	\item Крайне нежелательно размещать оператор default где-либо кроме как в конце списка case'ов.
\end{itemize}

\subsection{Специальные макросы}

В проекте часто используется целый ряд специальных макросов главным назначением которых является уменьшение кода 
и улучшение его читаемости. Большинство таких макросов определены в файле slib.h

\subsubsection{BIN булева унификация до целого 0 или 1}
Если необходимо привести результат выражения к одному из двух значений 0 или 1, то
вместо: 
\begin{lstlisting}	
    int result = some_function_returning_int(argument) ? 1 : 0;      
\end{lstlisting}
Следует писать:
\begin{lstlisting}	
    int result = BIN(some_function_returning_int(argument));
\end{lstlisting}

\subsubsection{LOGIC булева унификация до целого false или true}
Этот макрос аналогичен предыдущему с той лишь разницей, что возвращает true или false:
\begin{lstlisting}	
    bool result = some_function_returning_int(argument) ? true : false;
\end{lstlisting}
Следует писать:
\begin{lstlisting}	
    bool result = LOGIC(some_function_returning_int(argument));
\end{lstlisting}

\ppynote{
	Не применяйте макросы BIN и LOGIC к числам с плавающей точкой!
	Точно известно, что в компиляторе Microsoft Visual C 7.3 это работает не правильно.
	Таким образом, гарантии, что это будет правильно работать в общем нет никакой.
}

\begin{lstlisting}	
	assert(BIN(0.0) == 0); // Может выдать ошибку
\end{lstlisting}	

\subsubsection{MAX и MIN определение максимального и минимального, соответственно, значения из двух аргументов}
Это - очень популярные макросы в мире c/c++. Для проектов Papyrus они определены в slib.h и более нигде.
Используйте только эти макросы, но не min, max или что-либо еще.

Специальное исключение для библиотеки GDI+:
перед включением gdiplus.h следует переопределить макросы min и max следующим образом:
\begin{lstlisting}	 
	#define max MAX
	#define min MIN
	#include <gdiplus.h>
\end{lstlisting}

Иначе возникнут ошибки компиляции. В ближайшей перспективе мы намерены избавиться от зависимости
от GDI+.

\subsubsection{SIZEOFARRAY определение размера статического массива}
Часто возникает необходимость получить размер статического массива. Каноническим подходом является следующий:
\begin{lstlisting}	
       Entry array[591];
       for(size_t i = 0; i < sizeof(array) / sizeof(array[0]); i++) {
	       do_somthing_with_entry(array[i]);
	   }
\end{lstlisting}

Так как писать каждый раз sizeof(array) / sizeof(array[0]) утомительно, то многие программисты 
применяют макросы для этой конструкции. В библиотеке SLIB используется макрос SIZEOFARRAY.
Использование этого макроса в применении к примеру, приведенному выше, выглядит так:
\begin{lstlisting}	
       Entry array[591];
       for(size_t i = 0; i < SIZEOFARRAY(array); i++) {
	       do_somthing_with_entry(array[i]);
	   }
\end{lstlisting}

Будьте внимательны: попытка применить этот макрос к динамически распределяемому массиву или
к указателю, о размере данных, на которые он ссылается, компилятор ничего не знает, приведет к
фатальным последствиям.

Например, в следующем коде применение макроса SIZEOFARRAY недопустимо.
\begin{lstlisting}	
	void foo(Entry * pArray, uint entryCount) 
	{
	   // Не делайте так! НИКОГДА!
       for(size_t i = 0; i < SIZEOFARRAY(pArray); i++) { // @badcode
	       do_somthing_with_entry(pArray[i]);
	   }
	   // Компилятор не знает на массив какого размера ссылается pArray:
	   // здесь надо писать так:
       for(size_t j = 0; j < entryCount; j++) { // @goodcode
	       do_somthing_with_entry(pArray[j]);
	   }	
   }
\end{lstlisting}

Важным примером использования SIZEOFARRAY является вычисление массива unicode-символов (или 
же массива, элементы которого потенциально могут быть размером более одного байта).
Пример:
\begin{lstlisting}	
       TCHAR string_buf[591];
	   // Здесь нелья писать sizeof(string_buf) поскольку в общем случае не известно
	   // является длина элемента массива 1 байт или 2 байта 
	   // (это зависит от предопределений сборки проекта).
       do_somthing_with_string(string_buf, SIZEOFARRAY(string_buf));
\end{lstlisting}

\subsubsection{oneof}

Вместо конструкции 
\begin{lstlisting}	
       if(a == 1 || a == 3) 
\end{lstlisting}		
следует писать 
\begin{lstlisting}	
if(oneof2(a, 1, 3))
\end{lstlisting}		
аналогично 
\begin{lstlisting}	
       if(a == 1 || a == 3 || a == 8) 
\end{lstlisting}			
	следует писать 
\begin{lstlisting}		
	if(oneof3(a, 1, 3))
\end{lstlisting}		

В slib.h определены макросы от oneof2 до oneof14

\subsubsection{SETIFZ и SETIFZQ}

Вместо 
\begin{lstlisting}
       if(!a) 
          a = b; 
\end{lstlisting}		
       следует писать: 
\begin{lstlisting}	
       SETIFZ(a, b);
\end{lstlisting}

Макрос SETIFZ возвращает true если !!a or !!b. В случае, если нужно по-проще, то применяйте SETIFZQ.
Если код компилируется в conformance-mode, то применить SETIFZQ вместо SETIFZ вас вынудит компилятор.

\subsubsection{NZOR}
Вместо 
\begin{lstlisting}
       a = b ? b : c; 
\end{lstlisting}		
       следует писать: 
\begin{lstlisting}	
       a = NZOR(b, c);
\end{lstlisting}	

\subsubsection{SETMAX}

Вместо 
\begin{lstlisting}
       if(a < b)
          a = b;
\end{lstlisting}		
       следует писать:
\begin{lstlisting}	
       SETMAX(a, b); 
\end{lstlisting}	

\subsubsection{SETMIN}

Вместо 
\begin{lstlisting}
       if(a > b)
          a = b;
\end{lstlisting}		
       следует писать:
\begin{lstlisting}	
       SETMIN(a, b); 
\end{lstlisting}	

\subsubsection{SETFLAG установка/снятие битовых флагов}

Вместо
\begin{lstlisting}
       if(a) 
          flags |= f;
       else
          flags &= ~f;
\end{lstlisting}		
       следует писать:
\begin{lstlisting}	
       SETFLAG(flags, f, a);
\end{lstlisting}	

\subsubsection{ASSIGN\_PTR присваивание значения по указателю, если указатель не нулевой}

Вместо
\begin{lstlisting}
       if(p)
          *p = a;
\end{lstlisting}		
       следует писать:
\begin{lstlisting}	
       ASSIGN_PTR(p, a);
\end{lstlisting}	

\subsubsection{RVALUEPTR присваивает значению величину, на которую ссылается указатель, если последний не равен нулю}

Вместо
\begin{lstlisting}
       if(p)
          a = *p;
\end{lstlisting}		
       следует писать:
\begin{lstlisting}	
       RVALUEPTR(a, p);
\end{lstlisting}	

Кроме того, макрос RVALUEPTR возвращает !0 если его второй аргумент (указатель) не равен нулю и ноль в противном
случае. Этой особенностью можно пользоваться для альтернативной инициализации первого аргумента.

Например:
\begin{lstlisting}
      if(!RVALUEPTR(a, p)) 
          a = 0;
\end{lstlisting}		

\subsubsection{MEMSZERO обнуляет память, занятую переменной}
Подробно описан ниже. См. стр.~\pageref{sec-memops}.
	
\subsubsection{THISZERO обнуляет память, занятую переменной по указателю this}
Подробно описан ниже. См. стр.~\pageref{sec-memops}.

\subsubsection{INITWINAPISTRUCT специальная инициализация структур Win API}
Макрос обнуляет память, выделенную под структуру Win API имеющую член cbSize и 
присваивает этому члену размер структуры.

Например, конструкция:
\begin{lstlisting}
	SCROLLINFO si;
	INITWINAPISTRUCT(si);
\end{lstlisting}		

То же самое, что и:

\begin{lstlisting}
	SCROLLINFO si;
	MEMSZERO(si);
	si.cbSize = sizeof(si);
\end{lstlisting}

Задача этого макроса - максимально унифицировать код и сократить его размер.

\subsubsection{Простые преобразования типов указателей}

Следующие макросы осуществляют преобразования указателей к простым типам:
\begin{description}
	\item[PTR8(p)] Преобразует указатель p к типу (uint8 *)
	\item[PTR16(p)] Преобразует указатель p к типу (uint16 *)
	\item[PTR32(p)] Преобразует указатель p к типу (uint32 *)
	\item[PTR64(p)] Преобразует указатель p к типу (uint64 *)
	\item[PTRDBL(p)] Преобразует указатель p к типу (double *)
	\item[PTR8C(p)] Преобразует указатель p к типу (const uint8 *)
	\item[PTR16C(p)] Преобразует указатель p к типу (const uint16 *)
	\item[PTR32C(p)] Преобразует указатель p к типу (const uint32 *)
	\item[PTR64C(p)] Преобразует указатель p к типу (const uint64 *)
	\item[PTRDBLC(p)] Преобразует указатель p к типу (const double *)
	\item[PTRCHR(p)] Преобразует указатель p к типу (char *) используя static\_cast<>
	\item[PTRCHRC(p)] Преобразует указатель p к типу (const char *) используя static\_cast<>
	\item[PTRCHR\_(p)] Преобразует указатель p к типу (char *) используя reinterpret\_cast<>
	\item[PTRCHRC\_(p)] Преобразует указатель p к типу (const char *) используя reinterpret\_cast<>
\end{description}

\section{Универсальные семантические правила}

В этой секции будут рассмотрены общие спецификации и мнемоники для классов и функций.
В основном это - только рекомендации, но не строгие предписания. Не существует и не может
существовать правила, предписывающего обязательно в каждом случае выполнять эти рекомендации.

Вместе с тем, если вы определяете новый класс или модифицируете существующий, то
приведенные правила позволят одновременно уменьшить энтропию в исходных кодах системы и 
избежать лишних ошибок.

\subsection{Member function IsValid()}
Функция IsValid() проверяет корректность состояния экземпляра объекта.

Спецификация функции:
\begin{lstlisting}
	int IsValid() const;
\end{lstlisting}

Квалификатор \ppyrsrv{const} может быть опущен лишь в исключительных случаях и
с обязательным объяснением.

В общем случае, если метод IsValid() экземпляра объекта возвращает нулевое
значение, то использовать такой экземпляр нельзя. 

Важно: метод IsValid() не должен быть предназначен только для проверки корректности кода
объекта или консистентности внутреннего состояния экземпляра (хотя, кроме прочего, может и это делать). 
Это - не отладочная семантика. Метод IsValid() должен быть предназначен для регулярной 
продуктивной проверки состояния экземпляра объекта с целью выяснить можно ли его использовать.

Примеры классов, содержащих такой метод: SFile, SBuffer (пример non-const метода), GoodsToObjAssoc.

\subsection{Member function IsConsistent()}

Функция IsConsistent() проверяет экземпляр объекта на предмет возможности хоть как-то
его использовать. Другими словами, если эта функция возвращает 0, то никакие
операции в экземпляром невозможны - он находится в разрушенном состоянии.
В отличии от функции IsValid(), отрицательный результат которой лишь говорит о том,
что в экземпляре что-то не так, но с ним еще можно что-то сделать (разрушить, инициализировать
за-ново), отрицательный результат IsConsistent() вообще исключает возможность дальнейшего
взаимодействия с экземпляром.

Спецификация функции:
\begin{lstlisting}
	int IsConsistent() const;
\end{lstlisting}

Чаще всего, но не всегда, IsConsistent() реализуется посредством проверки предварительно
инициализированной сигнатуры экземпляра, значение которой стирается деструктором.

Необходимость в методе может быть обусловлена сложными взаимными ссылками между объектами,
из-за чего не всегда ясно был разрушен экземпляр до этого или нет.

Строго говоря, этот метод является полумерой, лишь иногда помогающей избежать катастрофических
последствий от неправильной обработки объектов, но, тем не менее, это часто срабатывает.

\subsection{Member function Z()}
Функция Z() инициализирует состояние экземпляра класса или
структуры. Эта функция не обязана и, чаще всего, не должна освобождать память, выделенную
под внутренние элементы класса если эта память может быть использована при дальнейшей
работе с экземпляром.

Функция должна вернуть ссылку на экземпляр this.

Пример:
\begin{lstlisting}
	class ABC {
	public:
		ABC() : A(0), P_Buf(0), UsedBufSize(0), AllocatedBufSize(0)
		{
		}
		~ABC()
		{
			// Деструктор, в отличии, от Z() освобождает память,
			// выделенную под P_Buf, но не трогает "плоские" переменные,
			// поскольку экземпляр объекта прекращает существование.
			SAlloc::F(P_Buf);
		}
		ABC & Z()
		{
			// Мы вернули состояние переменной A в исходное состояние.
			// Обнулили используемый размер буфера P_Buf, но 
			// не стали освобождать память, выделенную под 
			// этот буфер и менять AllocatedBufSize дабы
			// при последующем использовании не распределять память вновь.
			A = 0;
			UsedBufSize = 0;
			return *this;
		}
	private:
		long   A;
		void * P_Buf;
		size_t UsedBufSize;
		size_t AllocatedBufSize;
	}
\end{lstlisting}

\subsection{Member function Destroy()}
Функция-член Destroy() должна полностью освободить все ресурсы, занятые экземпляром объекта
кроме собственно самого экземпляра this. Вместе с тем, после вызова Destroy() все компоненты 
экземпляра должны быть валидными в том смысле, что любые дальнейшие операции с экземпляром 
допускаются. Например, если объект имеет внутренний указатель, распределением которого 
он управляет, то после освобождения внутреннего содержимого по этому указателю сам указатель должен быть
обнулен.

Спецификация функции:
\begin{lstlisting}
	void Destroy();
\end{lstlisting}

Ключевое отличие Destroy() от Z() в том, что Z() имеет право не освобождать внутренние 
ресурсы, если считает, что для последующего использования экземпляра они пригодятся.
У Destroy() такой опции нет.

В общем случае должно выполняться правило: если класс имеет метод Destroy(), 
то деструктор класса может быть имплементирован единственным вызовом Destroy().

Например:
\begin{lstlisting}
	class ABC {
	public:
		ABC()
		{
		}
		~ABC()
		{
			Destroy();
		}	
		void Destroy();
	};
\end{lstlisting}

\subsection{Member function IsEmpty()}
Функция-член IsEmpty возвращает ненулевое значение если экземпляр объекта является \qu{пустым}.
Термин \qu{пустой} интерпретируется в зависимости от типа объекта. 

Спецификация функции, в общем случае, следующая:
\begin{lstlisting}
int    IsEmpty() const;
\end{lstlisting}

Допускаются изменения указанной спецификации, однако, квалификатор const крайне важен. У вас должны
быть очень существенные основания для того, чтобы спецификация такого метода была бы non-const.

Если класс имеет методы Z() и IsEmpty(), то класс должен выполняться инвариант:

\begin{lstlisting}
	assert(instance.Z().IsEmpty());
\end{lstlisting}

\subsection{Member function IsEq()}
Функция-член IsEq() сравнивает экземпляр this некоторого объекта с экземпляром, переданным
единственным аргументом функции. Чаще всего типом этого аргумента является тот же класс, которому
принадлежит функция. Но это - не жесткое правило: могут быть и иные реализации IsEq, принимающие
в качестве аргумента какие-либо иные типы.

Аргумент функции в общем случае следует передавать по const-ссылке.

Функция возвращает значение типа int. Если this равен аргументу, то возвращается !0 (любое ненулевое значение: 
желательно единица, однако допустимы вариации). Если this не равен аргументу, то возвращает 0.

Функция всегда имеет квалификатор const, равно как и аргумент, передаваемый ей так же имеет квалификатор const. То есть
функция не меняет состояние this, равно как и состояние объекта, ссылка на который передана ей для сравнения.
Вероятно, исключения из этого правила могут существовать, но в таком случае это необходимо объяснить в комментариях.

Общее правило для формата вызова функций этого семейства FASTCALL. Правило не обязательное, но учитывая то,
что функция имеет единственный аргумент, применение FASTCALL в этом случае весьма эффективно (большинство
компиляторов, обрабатывающих FASTCALL, ничего на стеке передавать не будут - только в регистрах).

Пример (продолжим примеры с выдуманным классом ABC):
\begin{lstlisting}
	class ABC {
	public:
		ABC() : A(0), P_Buf(0), UsedBufSize(0), AllocatedBufSize(0)
		{
		}
		~ABC()
		{
			SAlloc::F(P_Buf);
		}
		bool   FASTCALL IsEq(const ABC & rS) const
		{
			bool   eq = true;
			// Попутно проверим очевидные инварианты класса
			assert(UsedBufSize <= AllocatedBufSize);
			assert(rS.UsedBufSize <= rS.AllocatedBufSize);
			assert(!UsedBufSize || P_Buf);
			assert(!rS.UsedBufSize || rS.P_Buf);
			if(A != rS.A)			
				eq = false;
			else if(UsedBufSize != rS.UsedBufSize)
				eq = false;
			else if(UsedBufSize && memcmp(P_Buf, rS.P_Buf, UsedBufSize) != 0) 
				eq = false;
			return eq;
		}
		ABC & Z()
		{
			A = 0;
			UsedBufSize = 0;
			return *this;
		}
	private:
		long   A;
		void * P_Buf;
		size_t UsedBufSize;
		size_t AllocatedBufSize;
	}
\end{lstlisting}

\subsection{Member function Copy()}
Метод Copy() реализует копирование экземпляра объекта, переданного аргументом функции
в экземпляр this.

Спецификация функции, в общем случае, следующая:
\begin{lstlisting}
	class ABC {
	public:
		int    FASTCALL Copy(const ABC & rS);
	};
\end{lstlisting}

Функция Copy() должна быть сконструирована так, чтобы реализовать полное (глубокое) копирование
rS в *this. В общем случае, реализация copy-constructor и operator = класса, при необходимости, 
должны быть имплементированы простым вызовом метода Copy().

Например:
\begin{lstlisting}
	class ABC {
	public:
		ABC()
		{
		}
		ABC(const ABC & rS)
		{
			Copy(rS);
		}
		ABC & FASTCALL operator = (const ABC & rS)
		{
			Copy(rS);
			return *this;
		}
		int    FASTCALL Copy(const ABC & rS);
	};
\end{lstlisting}

\subsection{Member function ToStr()}
Метод ToStr реализует преобразование экземпляра объекта в строку. Общие правила (которые не всегда выполняются)
следующие:
\begin{itemize}
	\item Функция имеет сигнатуру const. Это правило может не выполнятся только в редких исключениях.
	\item Строковый буфер, в который осуществляется вывод имеет тип SString \& и находится в конце
	списка аргументов функции.
	\item Функция предварительно очищает аргумент буфера вывода методом Z()
	\item Функция возвращает либо ссылку на аргумент буфера вывода либо целочисленный индикатор
	успешности выполнения.
\end{itemize}

\chapter{Общие функции}

В этой главе обсуждаются общеупотребимые функции и методы, а именно:
\begin{itemize}
	\item Распределение памяти
	\item Манипуляции с участками памяти (инициализация, копирование, перемещение)	
	\item Ввод-вывод
	\item Манипуляции со строковыми переменными и константами
	\item Математические функции
\end{itemize}

\section{Распределение памяти}

Функции malloc, calloc, realloc, free, определенные в стандартной библиотеке не используются в проекте на прямую.
Вместо них применяются статические функции класса SAlloc. Ниже приведено упрощенное определение этого класса.

\begin{lstlisting}
	class SAlloc {
	public:
		//
		// Descr: Функция, замещающая malloc.
		//
		static void * FASTCALL M(size_t sz);
		//
		// Descr: Функция, замещающая calloc.
		//
		static void * FASTCALL C(size_t n, size_t sz);
		//
		// Descr: Функция, замещающая realloc.
		//
		static void * FASTCALL R(void * ptr, size_t sz);
		//
		// Descr: Функция, замещающая free.
		//
		static void   FASTCALL F(void * ptr);
	};
\end{lstlisting}		

Существуют две причины, по которым реализовано такое замещение:
\begin{enumerate}
	\item Благодаря соглашению вызова FASTCALL код, использующий эти функции (а это очень значительное количество
	вызовов) становится компактнее. Отметим, что выигрыша в скорости вызова нет (чуть-чуть медленнее за счет избыточной
	вложенности).
	\item Появляется возможность (увы, пока не осуществленная) централизованно собирать статистику об обращениях к аллокатору памяти с целью реализации высокооптимизированного аллокатора. 
\end{enumerate}

\subsection{Проверка на null освобождаемой памяти}
Специальное замечание относительно освобождения памяти функциями free(), SAlloc::F()
и оператором delete: стандарты c/c++ гарантируют, что эти функции игнорируют нулевые
указатели. Поэтому не следует проверять на null указатели перед вызовом этих и родственных
функций - не надо загромождать и без того гигантский код.

Единственное исключение из вышеприведенного правила:  если вы абсолютно уверены, что
участок кода, где осуществляется освобождение распределенной памяти, критичен по 
быстродействию (очень часто вызывается, например, в циклах и т.д.) то проверка
на null перед вызовом функции (оператора) освобождения памяти поможет сэкономить "пару тактов"
процессора. Пометьте такую проверку комментарием // $@$speedcritical чтобы как-то оправдаться.

\section{Манипуляции с участками памяти\label{sec-memops}}

Функции memcpy, memmove, memset, memcmp опеределены в slib.h как макросы, для использования реализации из библиотеки 
Agner Fog (www.agner.org).

Для инициализации памяти нулевыми байтами вместо общеупотребимого memset(ptr, 0, size) используется собственная
функция memzero(ptr, size). Мотивацией для этого является удаление лишнего параметра в огромном числе вызовов, что 
в купе с соглашением вызова FASTCALL дает заметное снижение размера кода. Кроме того, функция memzero отдельно 
обрабатывает некоторые размеры инициализируемых участков памяти для ускорения.

Для обнуления участков памяти, размер которых может быть вычислен на этапе компиляции оператором sizeof используется
макрос MEMSZERO(). Пример:
\begin{lstlisting}
	void foo(void * ptr, size_t size)
	{
		char local_buf[256];
		MEMSZERO(local_buf); // Правильно: sizeof(local_buf) возвращает адекватный результат
		// MEMSZERO(ptr); // ! Ни в коем случае - будут обнулены 
			// только первые 4 байта (8 на x64)
		memzero(ptr, size); // Правильно
	}
\end{lstlisting}

Еще один макрос THISZERO() используется для полного обнуления экземпляра структуры или класса.
Часто используется в конструкторах.

Осторожно: этот макрос ни в коем случае не следует использовать для классов, имеющих виртуальные функции - 
он обнулит указатель на таблицу виртуальных функций в результате чего программа обязательно аварийно завершится
при попытке обращения к любой из виртуальных функций класса.

\begin{lstlisting}
	class SomeClass {
	public:
		SomeClass()
		{
			THISZERO(); // Здесь можно использовать. 
				// Класс не определяет ни одной виртуальной функции.
		}
		int    A;
		int    B;
	};
	
	class SomeClassWithVirtualFunctions {
	public:
		SomeClass()
		{
			THISZERO(); // ! Ни за что не делайте так - виртуальный 
				// деструктор или иные виртуальные функции заставляют 
				// компилятор вставить первым членом в экземпляре класса
				// указатель на таблицу виртуальных функций. 
				// В результате обнуления этот указатель станет нулевым.
		}
		virtual ~SomeClass()
		{
		}
		int    A;
		int    B;
	};	
\end{lstlisting}

\section{Функции для работы со строками}

В этой секции мы обсудим ряд часто используемых функций для манипуляции с z-строками (то есть,
классическими строками, состоящими из цепочки символов, завершающихся нулевым байтом).

\subsection{Обнуление строки}
Как правило для обрезания z-строки до нулевой длины применяют присваивание первому байту нуля.

\begin{lstlisting}
	char   str[64];
	str[0] = 0;
\end{lstlisting}

В случае, если участок памяти выделенный по указатель на z-строку гарантированно больше или равен
4 байтам, мы используем небольшую модификацию, которая номинально работает быстрее (фактически, разницу
никто не заметит).

\begin{lstlisting}
	char   str[64];
	PTR32(str)[0] = 0;
\end{lstlisting}

\subsection{Определение длины строки}

\subsubsection{Выяснение не является ли строка пустой}

При определении не является ли указатель на строку, переданный в качестве аргумента функции,
пустой строкой следует использовать функцию isempty() вместо простого сравнения первого байта с нулем.
Это намного безопаснее из-за того, что ликвидирует проблему потенциального обращения к 
нулевому указателю, который может быть использован как параметр при вызове функции.

\begin{lstlisting}
isempty(const char * pStr);
\end{lstlisting}

Например:

\begin{lstlisting}
   void foo(const char * pStr, int a)
   {
       if(!isempty(pStr)) {
	       // do something with pStr;
	   }
   }
\end{lstlisting}

\subsubsection{sstrlen и sstrleni}

Стандартная функция strlen почти идеальна в плане быстродействия, но имеет небольшие недостатки:
\begin{itemize}
	\item При передаче ей нулевого указателя вызывает системное исключение (не проверяет аргумент
	на ноль).
	\item При компиляции c++ принимает только параметр типа const char * (но отказывается работать
	с const uchar * без преобразования типов). 
	\item Для unicode-символов требуется отдельная функция wcslen
\end{itemize}

Последние 2 пункта можно было бы простить, но дополнительная проверка на ноль перед вызовом
strlen нагружает и без того сложный код. Потому мы чаще всего пользуемся функцией sstrlen,
определенной в slib.h.

Эта функция определена для аргументов типа (const char *), (const uchar *) и (const wchar\_t *).

Дополнительно в slib.h определены аналогичные 3 функции с именем strleni, возвращающие int, а не
size\_t. Это сделано из-за того что во многих случаях требуется получить именно знаковое значение (это -
просто трюк, реализованный для того, чтоб обойтись без лишних преобразований типов).

\subsection{Копирование строк}

\subsubsection{sstrcpy}
Несмотря на то, что очевидным решением для копирования одной z-строки в другую является
стандартная функция strcpy, мы чаще всего применяем собственную реализации sstrcpy().

Основная причина для такой подмены - небезопасность strcpy: эта функция не проверяет аргументы
на 0 (в общем случае). Кроме того, в библиотеке SLIB присутствуют 3 переопределенных функции
для параметров типа char *, uchar *, wchar *.

Вместе с вышесказанным следует отметить, что sstrcpy сильно уступает стандартной strcpy по
быстродействию из-за того, что компилятор превосходно оптимизирует вызовы strcpy.

\subsubsection{strnzcpy}

\begin{lstlisting}
	char * FASTCALL strnzcpy(char * pDest, const char * pSrc, size_t maxlen);
	char * FASTCALL strnzcpy(char * pDest, const uchar * pSrc, size_t maxlen);
	char * FASTCALL strnzcpy(char * pDest, const SString & rSrc, size_t maxlen);
	wchar_t * FASTCALL strnzcpy(wchar_t * pDest, const wchar_t * pSrc, size_t maxlen);	
\end{lstlisting}

Копирование строки в буфер с ограниченной длиной. Функция strncpy из стандартной библиотеки
не используется из-за странной особенности: если исходная длина превышает размер буфера
назначения, то завершающий ноль в буфере установлен не будет.

У функций семейства strnzcpy есть и собственная несколько необычная особенность: если 
параметр maxlen равен нулю, то функции считают буфер назначения (pDest) бесконечным (то есть,
работают как sstrcpy).

Вариант strnzcpy(char *, const SString \&, size\_t) реализован ради унификации в случае,
если источником данных является экземпляр основного высокоуровневого класса представления строк SString.

\subsubsection{Сравнение строк}


\chapter{Базовые типы данных}

Начнем обсуждение разработки с обзора используемых типов данных.
В этой главе мы сосредоточимся на базовых или элементарных типах, которые
применяются как самостоятельно, так и в составе более сложных структур.

\section{Целочисленные типы}

Наиболее простыми и популярными в использовании являются целочисленные
типы данных. 

\subsection{Классификация}

Целочисленные типы классифицируются по следующим двум критериям:

\begin{description}
	\item[Длина] Измеряется в байтах или битах. Типичными вариантами могут быть
	следующие:
	\begin{itemize}
		\item 1 байт
		\item 2 байта
		\item 4 байта
		\item 8 байт
	\end{itemize}
	
	Возможны и другие случаи, но они скорее могут рассматриваться как
	экзотические либо применяемые в узкоспециализированных областях.
	
	\item[Наличие знакового бита]
	Здесь существует только две возможности - либо знаковый бит
	присутствует (это будет самый старший бит в двоичном представлении
	типа), либо он отсутствует.
	
	Беззнаковые (uint) целые типы имеют диапазон 
	представления простирающийся от $0$ до $2^{s}-1$ в то время как
	знаковые (signed) представляют числа от $-(2^{s-1}-1)$ до $2^{s-1}-1$.
	
\end{description}

\subsection{Какие целочисленные типы мы используем}

Исходя из приведенной классификации, мы можем оперировать набором из 8
целочисленных типов. В действительности их получается несколько больше из-за
того, что некоторые такие типы данных дублируются (по разным причинам, от
исторических до нюансов восприятия).

Мы здесь перечислим те типы которыми будем пользоваться и приведем особенности
их применения:

\begin{description}
	\item[char] Стандарт. Знаковое целое число размером 1 байт. Размер не гарантируется.
	Используется для представления символов в мультибайтовых строках.
	
	\item[uchar] Беззнаковое целое число размером 1 байт. Размер не гарантируется.
	
	\item[wchar\_t] Условный стандарт (зависит от компилятора). Знаковое целое число размером 2 байта. 
	Размер не гарантируется. Используется для представления символов в unicode-строках.
	
	\item[short] Стандарт. Знаковое целое число размером 2 байта. Размер не гарантируется.
	
	\item[ushort] Беззнаковое целое число размером 2 байта. Размер не гарантируется.
	
	\item[int] Стандарт. Знаковое целое число размером 4 байта. Размер не гарантируется.
	Наиболее часто используемый целочисленный тип. Главный недостаток - отсутствие
	гарантии размера. По этому для хранимых (persistent) структур применять не
	рекомендуется, вместо него в этих случаях следует использовать int32.
	
	\item[uint] Беззнаковое целое число размером 4 байта. Размер не гарантируется.
	Чаще всего используется в качестве целочисленного счетчика, поскольку в этом качестве
	процессором	обрабатывается несколько оптимальнее, чем int.
	
	\item[long] Знаковое целое число размером 4 байта. Размер не гарантируется.
	Для 32-битных архитектур аналогичен int.
	
	\item[ulong] Беззнаковое целое число размером 4 байта. Размер не гарантируется.
	
	\item[int8] Знаковое целое число размером 1 байт. Размер гарантируется.
	\item[uint8] Беззнаковое целое число размером 1 байт. Размер гарантируется.
	\item[int16] Знаковое целое число размером 2 байта. Размер гарантируется.
	\item[uint16] Беззнаковое целое число размером 2 байта. Размер гарантируется.
	\item[int32] Знаковое целое число размером 4 байта. Размер гарантируется.
	\item[uint32] Беззнаковое целое число размером 4 байта. Размер гарантируется.
	\item[int64] Знаковое целое число размером 8 байт. Размер гарантируется.
	\item[uint64] Беззнаковое целое число размером 8 байт. Размер гарантируется.
	
	\item[size\_t] Стандарт. Беззнаковое целое число, используемое для представления размера
	участка памяти. 
	
	\item[ssize\_t] Знаковое целое число, используемое для представления размера
	участка памяти. Часто применяется для представления результата вычитания одного адреса
	из другого (если уменьшаемое меньше вычитаемого, то результат будет отрицательным, что
	неприемлемо для стандартного типа size\_t).
\end{description}

Что касается канонизированных типов с суффиксом \_t (int16\_t, uint32\_t и т.д.), то мы их не используем,
однако технически их применение возможно без ущерба для правильной компиляции кодов. 

\subsection{Общие подходы к выбору целочисленного типа в конкретных ситуациях}

При выборе целочисленного типа мы руководствуемся следующими соображениями:

\begin{itemize}
	\item В качестве счетчиков прямых (от меньшего к большему индексу) циклов следует применять uint. 
	\begin{lstlisting}
		for(uint i = 0; i < list.getCount(); i++) {
			// ...
		}
	\end{lstlisting}
	\item Циклы с обратным отсчетом (от большего к меньшему), если это for для предотвращения переполнения
	при переходе через ноль лучше использовать int. 
	\begin{lstlisting}
		for(int i = list.getCount()-1; i >= 0; i--) {
			// ...
		}
	\end{lstlisting}	
	
	Однако, вместо цикла for в таких случаях правильнее использовать if() do \{ \} while.
	Например:
	
	\begin{lstlisting}
		uint i = list.getCount();
		if(i) do {
			type & r_item = list.at(--i); // Обратите внимание на префиксный декремент
		} while(i);
	\end{lstlisting}		
	\item В persistent-структурах правильнее использовать целочисленные типы с гарантированным размером.
	Например:
	\begin{lstlisting}
		struct Entry { // @persistent
			int32  Ident;
			int16  Flags;
			uint8  F2;
			uint8  F3;
		};
	\end{lstlisting}
	
	\item Использования short, ushourt, int16, uint16 в большинстве случаев следует избегать. Они применяются
	в унаследованных интерфейсах либо в ситуациях, когда необходимо точно отмерить размер
	поля для структуры/класса.
	
	\item Однобайтовые целочисленные типы (char, uchar, uchar, int8, uint8) применяются либо для
	представления символов в multibyte-строках, либо при очень жестких требованиях к плотности структуры
	данных, либо для ручного выравнивания структур данных (uint8). В последнем случае такие поля помечаются
	комментарием @alignment. Например:
	
	\begin{lstlisting}
		struct Entry { // @persistent
			int32  Ident;
			int16  Flags;
			uint8  Reserve[2]; // @alignment Выравнивает предыдущее поле по границе 4 байт.
			double R;
		};
	\end{lstlisting}
		
	\item Для представления размера данных в локальных переменных почти всегда используется size\_t. 
	Но ни в коем случае не следует использовать size\_t для представления элементов структур данных.
	Этот запрет связан с тем, что код может компилироваться как для 32-разрядной так и для 64-разрядной
	компьютерной архитектуры в результате чего размер структуры и смещение ее членов будет меняться.
	
	\begin{lstlisting}
		void foo()
		{
			size_t data_size = sizeof(some_value); // Так правильно
		}
		
		struct SomeStruc {
			int  Ident;
			size_t S; // ! Так нельзя. Используйте либо uint, uint32 либо uint64.
			double R;
		};
	\end{lstlisting}
	
\end{itemize}

\subsubsection{Включенный файл stdint.h}
Основной каталог с include-файлами src/include содержит файл stdint.h. Это сделано для того, чтобы
упростить сборку внешних компонентов, импортированных из мира open-source.
 
\subsection{Аспекты переносимости}

Здесь мы приведем несколько замечаний, касающихся переносимости данных
между различными аппаратными платформами, операционными системами и 
языками программирования.

\subsubsection{Порядок следования байтов}

Разные процессорные архитектуры могут использовать разные соглашения о
порядке следования байтов в двух- и четырех-байтовых целых числах.

Существует два случая:

\begin{description}
	\item[little-endian]
	\item[big-endian]
\end{description}

\subsubsection{Бинарная совместимость с другими языками программирования}

При необходимости обмена бинарными данными между приложениями 
написанных на разных языках программирования может оказаться существенным
выбор типов данных. 

\section{Типы для представления нецелых чисел}

\subsection{Классификация}

Форматы данных для представления нецелых чисел будем классифицировать по следующим критериям:

\begin{description}
	\item[По признаку плавающей точки]
	Дробное число можно представить либо с фиксированной десятичной точкой, либо
	с плавающей.
	
	В первом случае, формат хранения неявно предполагает позицию десятичной точки,
	представляя при этом число фактически в целочисленном виде. Все операции с такими
	числами учитывают положение десятичной точки. Для этого вида представления применяются либо,
	так называемые, двоично-десятичные форматы, либо целочисленные типы, с неявным
	определением положения точки.
	
	Во втором случае формат содержит информацию о положении десятичной точки.
	Такое представление описывается семейством стандартов IEEE 754.
	
	\item[По длине]
	Числа с плавающей точкой (IEEE 754) могут иметь длину 4 или 8 байт.
	
	Двоично-десятичные числа с фиксированной точкой могут иметь, вообще говоря, произвольную 
	длину от 2 байт. Однако, в наших проектах мы чаще всего применяем 8-байтовые величины.
	
	Для чисел с фиксированной точкой в целочисленном формате мы обычно используем 4-байтовые
	целые (int32), с другой стороны, здесь так же нет ограничения для применения 1-, 2-, 8-байтовых
	целых типов (int8, int16, int64).
	
\end{description}

\section{Дата и время}

\subsection{Дата}

В библиотеке SLIB определен специальный тип LDATE, содержащий бинарное
представление даты и необходимые методы для работы с ней.

Вот иллюстрация бинарной структуры типа LDATE:

\begin{lstlisting}
	uint16 Year;
	uint8  Month;
	uint8  Day;
\end{lstlisting}

Таким образом, видно, что формат занимает 4 байта и использует структурированное
представление даты. Альтернативным для структурированного, является представление,
при котором дата хранится как количество дней, прошедших с какой-то фиксированной
даты.

\paragraph{Специальные значения даты}
	Значение ZERODATE содержит нулевую (пустую) дату.

\subsection{Время}

В библиотеке SLIB определена специальная структура LTIME, содержащая бинарное
представление даты и необходимые методы для работы с ней.

Вот иллюстрация бинарной структуры типа LTIME:

\begin{lstlisting}
	uint8  Hour;
	uint8  Minuts;
	uint8  Seconds;
	uint8  HandredthsOfSecond;
\end{lstlisting}	

Как и LDATE, данный тип занимает в памяти 4 байта.

\paragraph{Специальные значения времени}
	Значение ZEROTIME содержит нулевое время. Заметим, что нулевое время не
	является недопустимым. То есть, 00:00:00 - вполне допустимое значение.
	
\subsection{Дата-время}

Комбинированный тип LDATETIME (определен в SLIB.H) состоит из 8 байт. Старшие 4 байта
заняты типом LDATE, младшие - типом LTIME.

\subsection{Унифицированное масштабированное представление даты/времени}

Относительно недавно в проект введен новый тип данных SUniTime позволяющих хранить масштабируемое время. 

Декларируется в файле slib.h.

Бинарное представления этого типа состоит из 8 байт, самый старший из которых является индикатором,
обеспечивающим информацию о масштабировании времени, установленном в остальных 7 байтах.

\subsection{Диапазон дат}

Тип DateRange используется для представления диапазона дат. Он состоит из даты
нижней границы диапазона и даты верхней границы.

\begin{lstlisting}
	LDATE  low;
	LDATE  upp;
\end{lstlisting}

Существуют следующие особенности трактовки границ диапазона:

\begin{itemize}
	\item Если low равно ZERODATE, то нижняя граница не определена.
	\item Если upp равно ZERODATE, то верхняя граница не определена.
	\item Если upp не равно ZERODATE и low > upp, то период считается пустым.
	\ppynote{
		Класс DateRange содержит метод CheckAndSwap(), который меняет местами
		low и upp в таком случае.
	}
\end{itemize}

\section{Строковые типы}

\subsection{SString}
Основной класс для представления multibyte-строк в системе. Декларируется в файле slib.h.

\subsection{SStringU}
Основной класс для представления unicode-строк. Декларируется в файле slib.h.

\subsection{Проблема кодировки multibyte-строк}

Унификации кодировки строк в проекте Papyrus - проблема. Из-за работы система со множеством источников 
данных и учитывая возраст проекта накопилось значительное число неразрешенных вопросов.

Состояние вопроса следующее: базы данных используют кодировку cp866 (Windows OEM для русскоязычной версии
операционной системы). Эта же кодировка трактуется как "INNER" то есть основная внутренняя.
Далее, так как на текущий момент большая часть окружения для представления русских текстовых данных
использует кодировку windows-1251 (Windows ANSI для русскоязычной версии операционной системы) то такая 
кодировка трактуется как "OUTER" то есть внешняя. Эта терминология применена для постепенной унификации
кодировок первой целью которой является полный переход на OUTER-кодировку. Следующий этап предполагает
полный переход либо на UTF-8 либо на UNICODE.

Для трансляции кодировок для объектов SString используется функция SString::Transf() единственным аргументом
которой задается направление перекодировки:
\begin{description}
	\item[CTRANSF\_INNER\_TO\_OUTER 0x0102] Из внутренней во внешнюю кодировку (OEM->ANSI)
	\item[CTRANSF\_OUTER\_TO\_INNER 0x0201] Из внешней во внутреннюю кодировку (ANSI->OEM)
	\item[CTRANSF\_INNER\_TO\_UTF8  0x0103] Из внутренней в utf-8
	\item[CTRANSF\_OUTER\_TO\_UTF8  0x0203] Из внешней в utf-8
	\item[CTRANSF\_UTF8\_TO\_INNER  0x0301] Из utf-8 во внутреннюю
	\item[CTRANSF\_UTF8\_TO\_OUTER  0x0302] Из utf-8 во внешнюю
\end{description}

\subsubsection{Другие инструменты перекодировки}

\section{Другие типы данных}
Несколько типов данных, которые часто используются в проекте:
\begin{description}
	\item[S\_GUID\_Base] Базовое представление для GUID. Обеспечивает всю необходимую функциональность
	кроме конструктора и деструктора (ради возможности использовать как член union'ов).
	\item[S\_GUID] Наследуется от S\_GUID\_Base и реализует конструктор и деструктор.
	\item[SVerT]
	\item[SBaseBuffer]
	\item[STempBuffer] Динамически распределяемый буфер фиксированного размера, применяемый
	для временного хранения данных неизвестного во время компиляции размера.
	
	\item[SBuffer] Буфер для чтения и записи. Хранит одновременно указатели позиции считывания и
	позиции записи, благодаря чему позволяет реализовать смешанные операции чтения и записи.
	При записи, если размер вносимых данных превышает доступный объем буфера, динамически расширяется.
	\item[SColorBase] Базовое представление для цвета в формате ARGB. Обеспечивает основные
	функции для работы с цветом, но не содержит конструктора и деструктора.
	\item[SColor] Прямой наследник SColorBase с конструктором и деструктором.
	\item[SPoint2S] 2-х мерная точка с представлением каждой из ортогональных координат
	в формате int16. 
	
	Кроме представления точки применяется для представления пары размеров по ортогональным осям.
	\item[SPoint2I] 2-х мерная точка с представлением каждой из ортогональных координат
	в формате int. Используется, главным образом, при интеграции сторонних библиотек.
	\item[SPoint2R] 2-х мерная точка с представлением каждой из ортогональных координат
	в формате double.
	\item[SPoint2F] 2-х мерная точка с представлением каждой из ортогональных координат
	в формате float.	
	
	Кроме представления точки может применяться для представления пары размеров по ортогональным осям.
	\item[SPoint3R] 3-х мерная точка с представлением каждой из ортогональных координат
	в формате double.
	\item[SPoint3F] 3-х мерная точка с представлением каждой из ортогональных координат
	в формате float.	
	\item[TRect] 2-х мерный прямоугольник, представленный границами в виде левого верхнего
	и правого нижнего углов. В качестве координат углом использует SPoint2S.
	
	Иногда, кроме прямого назначения, используется для представления полей и отступов по
	четырем направлениям.
	\item[FRect] 2-х мерный прямоугольник, представленный границами в виде левого верхнего
	и правого нижнего углов. В качестве координат углом использует SPoint2F.
	
	Иногда используется для представления полей и отступов по четырем направлениям.	
\end{description}

\chapter{Базовые структуры данных}

\section{Базовый вектор SVectorBase}
Базовый класс, от которого порождены все остальные векторные классы. Реализует механизмы работы сплошного 
непрерывного вектора с плоскими элементами одинакового размера, доступ к которым осуществляется по индексу 
позиции в диапазоне [0..count-1].
Никаких виртуальных методов этот класс не декларирует. В результате он лишен механизма разрушения сложных
элементов.

\section{Массив (SArray)}
Порожден от SVectorBase. Включает в себя виртуальный деструктор и виртуальный метод freeItem(void *),
благодаря чему обеспечивает механизм разрушения отдельных элементов.

\section{Коллекция}
Объекты, порожденные от SArray и обеспечивающие хранение сложных элементов, требующих разрушения при удалении
из контейнера.

\section{Набор строк (StringSet)}

\chapter{Базовые алгоритмы}

В этой главе я планирую скомпоновать информацию о базовых алгоритмах, используемых не только
в рамках системы Papyrus, но и вообще имеющих важное значение в программировании.

\chapter{Доступ к базам данных}

\chapter{Объекты данных (классы семейства PPObject)}

\begin{description}
	\item[PPOBJ\_CONFIG] Конфигурация системы.
	\begin{description}
		\item[ObjID] 1
		\item[class] PPObjSecur
		\item[Заголовочная структура] PPSecur
		\item[Пакет] PPSecurPacket
	\end{description}
	
	Синглтон: единственный экземпляр на базу данных. Вместе с тем, пользователи и группы
	пользователей имеют порожденные от этого объекта внутренние структуры для того, чтобы
	переопределять некоторые параметры.
	
	\item[PPOBJ\_STATUS] ObjID=2      class PPObjSecur              
	Текущее состояние
	
	Не используется.
	
	\item[PPOBJ\_USRGRP] Группы пользователей.
	
	\begin{description}
		\item[ObjID] 3
		\item[class] PPObjSecur		
		\item[Заголовочная структура] PPSecur
		\item[Пакет] PPSecurPacket
	\end{description}	
	
	Группирующий объект, объединяющий несколько пользователей. Иерархия имеет фиксированную глубину.
	То есть, группа не может быть членом группы.
	
	\item[PPOBJ\_USR] Пользователи.
	
	\begin{description}
		\item[ObjID] 4
		\item[class] PPObjSecur				
		\item[Заголовочная структура] PPSecur
		\item[Пакет] PPSecurPacket
	\end{description}		
	
	Запись субъекта применения прав доступа и конфигурации. Каждый пользователь для работы с
	конкретной базой данных обязан авторизоваться, таким образом любой рабочий сеанс ассоциирован
	с некоторой записью этого типа.
	
	\item[PPOBJ\_UNIT] Единицы измерения.
	
	\begin{description}
		\item[ObjID] 5
		\item[class] PPObjUnit						
		\item[Заголовочная структура] PPUnit
		\item[Пакет] None
		\item[Кэш] Yes
	\end{description}			
	
	\item[PPOBJ\_CURRATE] Типы валютных курсов      
	
	\begin{description}
		\item[ObjID] 6
		\item[class] PPObjCurRateType						
		\item[Заголовочная структура] PPCurRateType
		\item[Пакет] None
		\item[Кэш] No
	\end{description}				
	
	\item[PPOBJ\_CITYSTATUS] Статусы населенных пунктов      
	
	\begin{description}
		\item[ObjID] 7
		\item[class] PPObjWorldObjStatus						
		\item[Заголовочная структура] PPWorldObjStatus
		\item[Пакет] None
		\item[Кэш] No
	\end{description}					
	  
	\item[PPOBJ\_PRSNKIND] Виды персоналий       
	
	\begin{description}
		\item[ObjID] 8
		\item[class] PPObjPersonKind						
		\item[Заголовочная структура] PPPersonKind
		\item[Пакет] None
		\item[Кэш] Yes
	\end{description}						
	
	\item[PPOBJ\_PRSNSTATUS] Юридические статусы персоналий        
	
	\begin{description}
		\item[ObjID] 9
		\item[class] PPObjPersonStatus						
		\item[Заголовочная структура] PPPersonStatus
		\item[Пакет] None
		\item[Кэш] Yes
	\end{description}							
	
	\item[PPOBJ\_STAFFRANK] ObjID=10     class PPObjReference          
	\item[PPOBJ\_OPRTYPE] Типы операций
	
	\begin{description}
		\item[ObjID] 11
		\item[class] PPObjOprType						
		\item[Заголовочная структура] PPOprType
		\item[Пакет] None
		\item[Кэш] No
	\end{description}								
	
	\item[PPOBJ\_OPRKIND] Виды операций       
	
	\begin{description}
		\item[ObjID] 12
		\item[class] PPObjOprKind						
		\item[Заголовочная структура] PPOprKind
		\item[Пакет] PPOprKindPacket
		\item[Кэш] Yes
	\end{description}									
	
	\item[PPOBJ\_ACCSHEET] Таблицы аналитических статей        
	
	\begin{description}
		\item[ObjID] 13
		\item[class] PPObjAccSheet						
		\item[Заголовочная структура] PPAccSheet
		\item[Пакет] None
		\item[Кэш] Yes
	\end{description}										
	
	\item[PPOBJ\_BNKACCTYPE] Типы банковских счетов
	
	\begin{description}
		\item[ObjID] 14
		\item[class] PPObjReference						
		\item[Заголовочная структура] ReferencTbl::Rec
		\item[Пакет] None
		\item[Кэш] No
	\end{description}											
	
	\item[PPOBJ\_PRICETYPE] unused Типы цен 
	
	\begin{description}
		\item[ObjID] 15
	\end{description}												
	
	\item[PPOBJ\_AMOUNTTYPE] Типы сумм документов
	
	\begin{description}
		\item[ObjID] 16
		\item[class] PPObjAmountType						
		\item[Заголовочная структура] PPAmountType
		\item[Пакет] PPAmountTypePacket
		\item[Кэш] Yes
	\end{description}												
	
	\item[PPOBJ\_CASHNODE] ObjID=17     class PPObjCashNode           
	Расчетные кассовые узлы     
	\item[PPOBJ\_ACTION] ObjID=18     class PPObjReference          
	События, регистрируемые в системном журнале
	\item[PPOBJ\_COUNTGRP] ObjID=19                                   unused
	\item[PPOBJ\_BCODESTRUC] ObjID=20     class PObjBarCodeStruc        
	Система внутренних штрих-кодов     
	\item[PPOBJ\_DBDIV] ObjID=21     class PPObjDBDiv              
	Разделы базы данных        
	\item[PPOBJ\_GOODSTYPE] ObjID=22     class PPObjGoodsType          
	Типы товаров       
	\item[PPOBJ\_PROBLEM] ObjID=23                                   unused
	\item[PPOBJ\_GOODSSTRUC] ObjID=24     class PObjGoodsStruc          
	Структуры товаров      
	\item[PPOBJ\_FORMULA] ObjID=25     class PPObjFormula            
	Формулы        
	\item[PPOBJ\_SCALE] ObjID=26     class PPObjScale              
	Электронные весы       
	\item[PPOBJ\_ELINKKIND] ObjID=28     class PPObjELinkKind          
	Виды адресов электронной связи     
	\item[PPOBJ\_REGISTERTYPE] ObjID=27     class PPObjRegisterType       
	Типы регистрационных документов        
	\item[PPOBJ\_QUOTKIND] ObjID=29     class PPObjQuotKind           
	Виды котировок     
	\item[PPOBJ\_PERSONOPKIND] ObjID=30     class PPObjPsnOpKind          
	Вид персональной операции      
	\item[PPOBJ\_TAG] ObjID=31     class PPObjTag                
	Тэги объектов      
	\item[PPOBJ\_GOODSTAX] ObjID=32     class PPObjGoodsTax           
	Налоговые группы товаров       
	\item[PPOBJ\_BCODEPRINTER] ObjID=33     class PPObjBarcodePrinter     
	Принтеры штрихкодов        
	\item[PPOBJ\_CURRENCY] ObjID=34     class PPObjCurrency           
	Валюты     
	\item[PPOBJ\_CURRATETYPE] ObjID=35     class PPObjCurRateType        
	Типы валютных курсов       
	\item[PPOBJ\_OPCOUNTER] ObjID=36     class PPObjOpCounter          
	Счетчики документов     
	\item[PPOBJ\_GOODSCLASS] ObjID=37     class PPObjGoodsClass         
	Отраслевые классы товаров       
	\item[PPOBJ\_GOODSBASKET] ObjID=40     class PPObjGoodsBasket        
	Корзина товаров     
	\item[PPOBJ\_BHT] ObjID=41     class PPObjBHT                
	BHT-терминалы       
	\item[PPOBJ\_SCARDSERIES] ObjID=42     class PPObjSCardSeries        
	Серия персональных карт
	\item[PPOBJ\_STYLOPALM] ObjID=43     class PPObjStyloPalm          
	PDA Palm        
	\item[PPOBJ\_ASSTWROFFGRP] ObjID=44     class PPObjAssetWrOffGrp      
	Группа списания активов     
	\item[PPOBJ\_DRAFTWROFF] ObjID=45     class PPObjDraftWrOff         
	Конфигурация списания драфт-документов      
	\item[PPOBJ\_ADVBILLKIND] ObjID=46     class PPObjAdvBillKind        
	Виды первичных документов (например, для авансовых отчетов)
	\item[PPOBJ\_TRANSPMODEL] ObjID=47     class PPObjReference          
	Модели транспортных средств     
	\item[PPOBJ\_INTERNETACCOUNT] ObjID=48     class PPObjInternetAccount    
	Почтовые учетные записи     
	\item[PPOBJ\_PERSONRELTYPE] ObjID=49     class PPObjPersonRelType      
	Тип отношения между персоналиями        
	\item[PPOBJ\_PRSNCATEGORY] ObjID=50     class PPObjReference          
	Категории персоналий        
	\item[PPOBJ\_BILLSTATUS] ObjID=51     class PPObjBillStatus         
	Статусы документов      
	\item[PPOBJ\_TOUCHSCREEN] ObjID=52     class PPObjTouchScreen        
	TouchScreen     
	\item[PPOBJ\_DUTYSCHED] ObjID=53     class PPObjDutySched          
	Расписания дежурств      
	\item[PPOBJ\_DATETIMEREP] ObjID=54     class PPObjDateTimeRep        
	Периодичность        
	\item[PPOBJ\_LOCPRINTER] ObjID=55     class PPObjLocPrinter         
	Принтеры, привязанные к складам      
	\item[PPOBJ\_SALCHARGE] ObjID=56     class PPObjSalCharge          
	Схема начисления зарплаты        
	\item[PPOBJ\_STAFFCAL] ObjID=58     class PPObjStaffCal           
	Штатный календарь        
	\item[PPOBJ\_NAMEDOBJASSOC] ObjID=59     class PPObjNamedObjAssoc      
	Именованные ассоциации объектов
	\item[PPOBJ\_BIZSCORE] ObjID=60     class PPObjBizScore           
	Определители бизнес-показателей
	\item[PPOBJ\_GLOBALUSERACC] ObjID=61     class PPObjGlobalUserAcc      
	Учетная запись глобального пользователя (внешнего по отношению к текущей базе данных)
	\item[PPOBJ\_GOODSVALRESTR] ObjID=62     class PPObjGoodsValRestr      
	Ограничения товарных величин
	\item[PPOBJ\_PALLET] ObjID=63     class PPObjPallet             
	Складские паллеты
	\item[PPOBJ\_DEBTDIM] ObjID=64     class PPObjDebtDim            
	Размерность расчета долгов по документам
	\item[PPOBJ\_EVENTTOKEN] ObjID=65                                   
	Специальный объект, используемый как уникальная метка для событий.
	\item[PPOBJ\_SMSPRVACCOUNT] ObjID=66     class PPObjSmsAccount         
	Учетная запись провайдера рассылки SMS
	\item[PPOBJ\_PHONESERVICE] ObjID=67     class PPObjPhoneService       
	Оборудование компьютерной телефонии
	\item[PPOBJ\_GTACTION] ObjID=68     class PPObjGtaAction          
	События, регистрируемые в журнале тарфицируемых операций глобальных аккаунтов
	\item[PPOBJ\_SENDSMS] ObjID=69                                   
	Отправка смс
	\item[PPOBJ\_UHTTSTORE] ObjID=70     class PPObjUhttStore          
	Интернет-магазин Universe-HTT
	\item[PPOBJ\_GENERICDEVICE] ObjID=71     class PPObjGenericDevice  
	Обобщенное устройство
	\item[PPOBJ\_WORKBOOK\_PRE813] ObjID=72                             
	Элемент сайта
	\item[PPOBJ\_USERPROFILE] ObjID=73
	\item[PPOBJ\_EDIPROVIDER	] ObjID=74     class PPObjEdiProvider        
	Провайдеры EDI-обмена
	\item[PPOBJ\_USREXCLRIGHTS] ObjID=75                                   
	Исключения для пользовательских прав доступа при некоторых действиях
	\item[PPOBJ\_STAFFLIST2] ObjID=76                                   
	Штатное расписание (2-я версия объекта - записи перемещены из
	\item[PPOBJ\_ACCOUNT2] ObjID=77                                   
	Бухгалтерские счета (балансовые) (2-я версия объекта - записи перемещены из
	\item[PPOBJ\_TIMESERIES] ObjID=78     class PPObjTimeSeries         
	Временные серии. Специализированный объект, служащий в качестве заголовков временных серий данных.
	\item[PPOBJ\_FREIGHTPACKAGETYPE] ObjID=79     class PPObjFreightPackageType 
	Тип транспортной упаковки
	\item[PPOBJ\_DYNAMICOBJS] ObjID=100    class PPObjDynamicObjs        
	Список динамических объектов     
	\item[PPOBJ\_WOODBREED] ObjID=101    class PPObjReference          
	Породы древесины     
	\item[PPOBJ\_SLVP] ObjID=102                                  
	Поправки объемов бревен      
	\item[PPOBJ\_UNASSIGNED] ObjID=1000         
	\item[PPOBJ\_COUNTRY] ObjID=1001   class PPObjCountry            
	Государства      
	\item[PPOBJ\_REGION] ObjID=1002   class PPObjRegion             
	Регионы      
	\item[PPOBJ\_CITY] ObjID=1003   class PPObjCity               
	Населенные пункты        
	\item[PPOBJ\_PERSON] ObjID=1004   class PPObjPerson             
	Персоналии       
	\item[PPOBJ\_BACCT] ObjID=1005   class PPObjBnkAcct            
	Банковские счета        
	\item[PPOBJ\_ARTICLE] ObjID=1006   class PPObjArticle            
	Статьи аналитического учета     
	\item[PPOBJ\_ACCOUNT] ObjID=1007   class PPObjAccount            
	Бухгалтерские счета (балансовые)        
	\item[PPOBJ\_GOODSGROUP] ObjID=1008   class PPObjGoodsGroup         
	Группы товаров      
	\item[PPOBJ\_GOODS] ObjID=1009   class PPObjGoods              
	Товары      
	\item[PPOBJ\_LOCATION] ObjID=1010   class PPObjLocation           
	Локации. Адреса, склады.
	\item[PPOBJ\_BILL] ObjID=1011   class PPObjBill               
	Документы       
	\item[PPOBJ\_ACCTURN] ObjID=1012   class PPObjAccTurn            
	Бухгалтерские проводки        
	\item[PPOBJ\_QCERT] ObjID=1013   class PPObjQCert              
	Сертификаты качества      
	\item[PPOBJ\_PRICELIST] ObjID=1014                                 
	Прайс-листы        
	\item[PPOBJ\_VATBOOK] ObjID=1015   class PPObjVATBook            
	Книги продаж и покупок        
	\item[PPOBJ\_REGISTER] ObjID=1017   class PPObjRegister           
	Регистрационные документы     
	\item[PPOBJ\_PERSONEVENT] ObjID=1018   class PPObjPersonEvent        
	Персональные события      
	\item[PPOBJ\_INVENTORY] ObjID=1019                                 
	Инвентаризаци        
	\item[PPOBJ\_STAFFLIST] ObjID=1021   class PPObjStaffList          
	Штатное расписание        
	\item[PPOBJ\_LOT] ObjID=1022                                 
	Лоты      
	\item[PPOBJ\_CSESSION] ObjID=1023   class PPObjCSession           
	Кассовые сессии       
	\item[PPOBJ\_ACCTREL] ObjID=1024                                 
	Бухгалтерские связки     
	\item[PPOBJ\_OBJASSOC] ObjID=1025                                 
	Ассоциации объектов      
	\item[PPOBJ\_PACKAGE] ObjID=1026                                 
	Товарные пакеты      
	\item[PPOBJ\_PCKGTYPE] ObjID=1027   class PPObjPckgType           
	Types of goods packages      
	\item[PPOBJ\_TRANSPORT] ObjID=1028   class PPObjTransport          
	Транспортные средства        
	\item[PPOBJ\_QUOT] ObjID=1039   class PPObjQuotKind           
	Котировки        
	\item[PPOBJ\_GOODSREST] ObjID=1030                                 
	Остатки товаров (синхронизируется)      
	\item[PPOBJ\_SCARD] ObjID=1031   class PPObjSCard              
	Пластиковые карточки     
	\item[PPOBJ\_CCHECK] ObjID=1032                                 
	Кассовые чеки       
	\item[PPOBJ\_PROJECT] ObjID=1033   class PPObjProject            
	Проекты      
	\item[PPOBJ\_BRAND] ObjID=1034   class PPObjBrand              
	Брэнды       
	\item[PPOBJ\_MRPTAB] ObjID=1035   class PPObjMrpTab             
	MRP-таблицы      
	\item[PPOBJ\_PRJTASK] ObjID=1036   class PPObjPrjTask            
	Задачи по проекту        
	\item[PPOBJ\_PROCESSOR] ObjID=1037   class PPObjProcessor          
	Процессоры        
	\item[PPOBJ\_TECH] ObjID=1038   class PPObjTech               
	Технологии      
	\item[PPOBJ\_TSESSION] ObjID=1039   class PPObjTSession           
	Процессорные сессии     
	\item[PPOBJ\_DFCREATERULE] ObjID=1040   class PPObjDraftCreateRule    
	Правила для создания драфт документа        
	\item[PPOBJ\_BILLSYMB] ObjID=1041                                 
	Символы формул сумм документов (используется только для организации кэша)
	\item[PPOBJ\_DBXCHG] ObjID=1042                                 
	Обмен данными между разделами      
	\item[PPOBJ\_WORLD] ObjID=1043   class PPObjWorld              
	Географические объекты         
	\item[PPOBJ\_GOODSINFO] ObjID=1044   class PPObjGoodsInfo          
	\item[PPOBJ\_PERSONPOST] ObjID=1045                                 
	Должностные назначения
	\item[PPOBJ\_BUDGET] ObjID=1054   class PPObjBudget             
	Бюджеты
	\item[PPOBJ\_BIZSCTEMPL] ObjID=1055   class PPObjBizScTempl         
	Шаблоны бизнес показателей
	\item[PPOBJ\_RFIDDEVICE] ObjID=1057   class PPObjRFIDDevice         
	rfid устройства
	\item[PPOBJ\_SPECSERIES] ObjID=1058   
	\item[PPOBJ\_EADDR] ObjID=1059
	\item[PPOBJ\_COMPGOODS] ObjID=1065  
	Товары с составляющими
	\item[PPOBJ\_WORKBOOK] ObjID=1066   class PPObjWorkbook           
	рабочие книги (замещает PPOBJ\_WORKBOOK\_PRE813)
	\item[PPOBJ\_KEYWORD] ObjID=1067    
	Ключевые слова
	\item[PPOBJ\_FIAS] ObjID=1069       
	Объект, управляющий данными справочника адресов России ФИАС. Не является полноправным PPObject'ом
\end{description}

\chapter{Контроллеры анализа данных (классы семейства PPView)}

\begin{description}
	\item[class PPView]
	Базовый класс для реализации механизмов контроллера анализа данных.
	\item[class PPViewStaffList]          
	Штатное расписание. Дополнительный объект: Организация и подразделение.
	\item[class PPViewStaffPost]          
	Штатные назначения. Дополнительный объект: Сотрудник, организация и подразделение.
	\item[class PPViewSalary]             
	Зарплата. Дополнительный объект: Персоналия.
	\item[class PPViewPersonEvent]                                         
	Персональные события. Выбранный период.
	\item[class PPViewPerson]             
	Персоналии. Поле “SrchStr” фильтра
	\item[class PPViewSysJournal]         
	Системный журнал. Выбранный период.
	\item[class PPViewGoods]              
	Товары. Выбранный период и поле “SrchStr” фильтра.
	\item[class PPViewGoodsStruc]         
	Структура товаров.                см. PPViewGoods
	\item[class PPViewQuot]               
	Котировки. Диапазон значений котировки.
	\item[class PPViewQCert]              
	Сертификат качества. Строка, содержащаяся в коде и внутренний код
	\item[class PPViewInventory]          
	Инвентаризация. Диапазон значений, флаги фильтра в двоичном представлении.
	\item[class PPViewDvcLoadingStat]                                      
	Выбранный период.
	\item[class PPViewDLSDetail]           
	\item[class PPViewProcessor]          
	Процессоры.
	\item[class PPViewTech]               
	Технологии.
	\item[class PPViewTSession]          
	Технологические сессии. Выбранный период; ID суперсессии
	\item[class PPViewTSessAnlz]          
	Анализ технологических сессий. Выбранный период.
	\item[class PPViewTSessLine]          
	Строки технологических сессий. Период начала сессии, кол-во в списке
	\item[class PPViewBill]               
	Документы. Период; период оплаты;
	\item[class PPViewAccturn]
	Бухгалтерские проводки. Выбранный период, диапазон значений (поле фильтра “AmtR”)
	\item[class PPViewLot]                
	Лоты. Период поступления; операционный период; серийный номер; диапазоны цен поступления и реализации
	\item[class PPViewAsset]              
	Основные средства.
	\item[class PPViewPredictSales]            
	\item[class PPViewGoodsRest]          
	Остатки товаров. Период прогноза.
	\item[class PPViewGoodsTaxAnalyze]        
	\item[class PPViewPriceList]          
	Прайс-лист. Период прихода товаров.
	\item[class PPViewDebtTrnovr]         
	Долговая ведомость.
	\item[class PPViewShipmAnalyze]           
	Анализ отгрузки.
	\item[class PPViewAccount]            
	Бухгалтерские счета.
	\item[class PPViewCurRate]         
	\item[class PPViewBalance]            
	Бухгалтерский баланс.
	\item[class PPViewAccAnlz]            
	Анализ бухгалтерского счета.                     Выбранный период
	\item[class PPViewVatBook]            
	Книга продаж/покупок.
	\item[class PPViewTrfrAnlz]            
	Анализ товарных операций.
	\item[class PPViewOpGrouping]          
	Группировка товарных операций.
	\item[class PPViewGoodsMov]           
	Движение товаров. Выбранный период.
	\item[class PPViewCSess]           
	\item[class PPViewCSessExc]            
	\item[class PPViewCCheck]             
	Кассовые чеки. Выбранный период.
	\item[class PPViewObjSync]         
	\item[class PPViewTrfrAnlz]            
	\item[class PPViewGoodsOpAnalyze]     
	Группировка товарных операций. Выбранный период; период для сравнения; кол-во товаров в списке; кол-во документов в списке.
	\item[class PPViewSCard]              
	Персональные карты.
	\item[class PPViewSCardOp]            
	Операция по персональной карте.
	\item[class PPViewArticle]            
	Статьи аналитического учета.
	\item[class PPViewGoodsBasket]        
	Корзина товаров.
	\item[class PPViewGoodsTrnovr]         
	Товарооборот.
	\item[class PPViewPaymPlan]           
	План продаж.
	\item[class PPViewSStat]           
	Статистика продаж.
	\item[class PPViewOprKind]            
	Виды операций.
	\item[class PPViewMrpTab]            
	MRP-таблицы.
	\item[class PPViewMrpLine]            
	Строки MRP-таблиц.
	\item[class PPViewPrjTask]         
	Задачи.
	\item[class PPViewProject]            
	Проекты.      
	\item[class PPViewPriceAnlz]          
	Анализ цен.
	\item[class PPViewRptInfo]         
	\item[class PPViewPersonRel]           
	\item[class PPViewLogsMonitor]        
	Монитор журналов. Список файлов журналов, не более 3х.
	\item[class PPViewAmountType]         
	Типы сумм документов.
	\item[class PPViewBizScore]
	\item[class PPViewBizScoreVal]
	\item[class PPViewBizScTempl]
	\item[class PPViewBizScValByTempl]
	\item[class PPViewBrand]              
	Бренды.
	\item[class PPViewBrowser]            
	Класс, реализующий отображение таблицы контроллера анализа данных.
	\item[class PPViewBudget]             
	Бюджеты.
	\item[class PPViewCashNode]           
	Кассовые узелы.
	\item[class PPViewCheckOpJrnl]
	\item[class PPViewDBDiv]
	\item[class PPViewDBMonitor]
	\item[class PPViewDebtorStat]         
	Анализ Статистика по должникам.
	\item[class PPViewDialog]             
	\item[class PPViewDisplayExtList]     
	Список дополнительных полей для вывода.
	\item[class PPViewFreight]            
	Фрахты.
	\item[class PPViewGeoTracking]        
	Гео-трекинг.
	\item[class PPViewGlobalUserAcc]      
	Глобальнае учетные записи.
	\item[class PPViewGoodsBillCmp]
	\item[class PPViewGoodsMov2]
	\item[class PPViewGoodsToObjAssoc]
	\item[class PPViewGtaJournal]
	\item[class PPViewJob]
	\item[class PPViewLinkedBill]         
	Документы, связанные с каким-либо конкретным иным документов.
	\item[class PPViewLocTransf]
	\item[class PPViewLotExtCode]         
	Дополнительные коды по лотам.
	\item[class PPViewLotOp]              
	Операции по лоту.
	\item[class PPViewObjLikeness]
	\item[class PPViewObjSyncCmp]
	\item[class PPViewObjSyncQueue]
	\item[class PPViewPalm]
	\item[class PPViewPhnSvcMonitor]
	\item[class PPViewPrcBusy]
	\item[class PPViewRegisterType]        
	Тип регистрационных документов.
	\item[class PPViewReport]              
	Отчеты.
	\item[class PPViewScale]
	Электронные весы.
	\item[class PPViewServerStat]          
	Статистика сервера Papyrus.
	\item[class PPViewSpecSeries]          
	Специальные серии.
	\item[class PPViewStaffCal]            
	\item[class PPViewStockOpt]
	\item[class PPViewSuprWare]
	\item[class PPViewTimeSeries]
	\item[class PPViewTransport]           
	Транспортные средства.
	\item[class PPViewUhttSCardOp]
	\item[class PPViewUserProfile]         
	Профили пользовательских функций.
	\item[class PPViewVetisDocument]
	Ветеринарные документы Ветис Меркурий.
\end{description}

\chapter{Соображения по вопросу неотрицательности товарных остатков}

\chapter{Котировки}

Под котировкой подразумевается некоторое значение (чаще всего, но не обязательно,
имеющее смысл цены), ассоциированное с товаром и, одновременно, сопоставленное с
рядом факторов, от которых зависит применение этой котировки в конкретной ситуации.

Набор факторов на текущий момент выглядит так:

\begin{description}
	\item[Вид котировки] Основной классифицирующий параметр котировки. 
	Справочник видов котировок может содержать произвольное число записей.
	Каждый вид определяет назначение и набор характеристик, влияющих на
	использование котировки.
	
	Один вид зарезервирован - это базовая котировка (идентификатор 1).
	
	Кроме того, существует деление видов котировок на классы. В общем, понятие класса
	котировок необходимо для семантического разделения обычных котировок (обычно представляющих цены) 
	от специализированных (как то, товарная матрица, контрактные цены и т.д.).
	
	\item[Склад]
	Привязка значения котировки к складу обеспечивает дифференциацию по складам.
	
	Здесь важны два следующих нюанса:
	\begin{itemize}
		\item Котировка может быть не привязана ни к какому складу (для всех складов). Такое
		значение имеет меньший приоритет при использовании, нежели котировка, привязанная к
		конкретному складу.
		\item Котировка может быть привязана к группирующему складу. В этом случае существует
		наследование значений по иерархии складов. Так же, как и в предыдущем пункте, более точное
		значение переопределяет менее точное. То есть, значение, заданное для конкретного склада
		имеет больший приоритет, чем значение, заданное для складской группы, содержащей этот склад.
	\end{itemize}
	
	\item[Аналитическая статья]
	
	\item[Валюта]
	
	\item[Минимальное количество]
	
\end{description}

%В этой небольшой главе мы опишем основные изменения, которые претерпела
%техника работы с котировками с системе \ppybrand{}, начиная с версии 7.2.0.

\chapter{Модель объемной оптимизации товарных запасов}

В этой главе я приведу наброски математической модели объемной оптимизации 
товарных запасов.

\section{Модель расчета доходности запаса одного товара}

Первое, что необходимо сделать для объемной оптимизации запасов, это - определить
методику расчета целевой функции по одному товару и необходимые для этого исходные 
данные.

\subsection{Исходные данные для расчета доходности запаса одного товара}

Основные параметры товара, необходимые для расчетов, следующие:

\begin{description}
	\item[ИД товара ($GoodsID$)] Целочисленный уникальный идентификатор товара. 
	
	\item[Себестоимость единицы товара ($c$)] Цена одной единицы товара, 
	которая уплачивается поставщику, либо затрачивается при производстве этого товара.
	Себестоимость может включать прямые издержки на доставку или производство, но 
	не должна содержать издержек на хранение и продажу.
	
	\item[Цена продажи единицы товара ($p$)] Цена, по которой будет продана одна единица
	товара из текущего (рассчитываемого) запаса. Важно что бы эта величина включала (в усредненном
	виде) все возможные скидки, которые могут быть предоставлены покупателям.
	
	\item[Средние ежедневные продажи товара (в торговых единицах) ($D$)]
	Среднее количество торговых единиц товара, которое может быть продано за один день.
\end{description}

Кроме того, на товар могут быть наложены ограничения, связанные с особенностями
поставки, хранения и продажи.

Вот список параметров товара, отражающих такие ограничения:

\begin{description}
	\item[Емкость упаковки поставки в торговых единицах ($Pckg$)]
	Минимальное количество торговых единиц товара, которое может быть закуплено у поставщика.
	Одновременно, данный параметр отражает кратность закупаемой у поставщика (или производимой) 
	партии товара. То есть, модель предполагает, что запасы не могут увеличиваться на величину,
	которая не кратна $Pckg$.
	
	\item[Срок годности в днях ($ExpiryPeriod$)]
	Максимальное количество дней, в течении которых товар может храниться до момента продажи.
	
	\item[Минимальный запас в торговых единицах ($MinStock$)]
	Количество торговых единиц товара, которое обязательно должно быть в запасе.

\end{description}

\subsection{общие параметры модели}

Существует несколько параметров, которые являются общими для всех товаров, обрабатываемых моделью:

\begin{description}
	\item[Норма прибыли в долях единицы ($r$)]
	Один из наиболее важных параметров, используемый для расчета стоимости 
	хранения товарных запасов. Смысл этого значения заключается в оценке минимальной
	доходности инвестиций в товарные запасы.
	Ориентировочно, методика определения величины параметра следующая:
	\begin{itemize}
		\item Рассчитываются годовые издержки на содержание помещения склада (магазина) за прошедший
		год (включая издержки на складское оборудование).
		\item Рассчитываются годовые издержка на заработную плату сотрудникам склада (магазина), 
		непосредственно занятым в хранении и продаже товарных запасов, за прошедший год.
		\item Определяются среднедневные запасы за прошедший год.
		\item Сумма первых двух значений делится на третью величину. В результате получается годовая норма
		издержек на хранение и продажу.
		\item К норме хранения прибавляется рыночная стоимость капитала (средняя банковская процентная ставка на 
		суммы, сопоставимые с себестоимостью среднедневных остатков товаров).
	\end{itemize}
	
	\item[Коэффициент запаса учета срока годности]
	Для того, чтобы модель могла использовать срок годности товаров для ограничения их запасов,
	необходимо правило, определяющее предельный запас независимо от абсолютной даны производства 
	и поступления на склад хранения. 
	Описываемая модель применяет следующее правило: если для товара указан срок годности, то
	максимальный запас должен быть израсходован за период, равный сроку годности, умноженному на
	коэффициент запаса.
	
	Данный коэффициент должен быть больше нуля и меньше или равен единице.

	\item[Максимальная суммарная себестоимость товарных запасов]
	
	\item[Максимальная дневная сумма продаж]
\end{description}

\subsection{Допущения модели}

\begin{itemize}
	\item Весь расход запасов является доходным. То есть модель не рассматривает
	отдельно безвозвратные потери товаров, не приносящие прибыли.
	\item Правомерно применять к расчету показатели бизнеса за предыдущие периоды.
	\item Продажи товаров не интерферируют между собой. Это - одно из самых досадных 
	допущений. В действительности, продажи одного товара влияют на продажи других,
	однако это взаимодействие настолько сложно описать формально, что пришлось ввести
	данное допущение.
	\item Запасы уменьшаются в течении времени линейно пропорционально среднедневным
	продажам ($D$). 
	
	При дальнейшем усложнении модели, вероятно мы введем вероятностные оценки продаж,
	но на первоначальном этапе будем пользоваться наиболее простым правилом.
\end{itemize}

\subsection{Расчет дохода}

Функция дохода рассчитывается как простое произведение запаса на цену реализации.
То есть:

$$
	I = R \cdot p
$$

Обратим внимание на то, что при расчете доходности не учитывается временная стоимость
входящего денежного потока. Причина в том, что временная стоимость полностью учтена 
в функции издержек. Этот нюанс является спорным и, возможно, будет пересмотрен в дальнейшем.

\subsection{Расчет расходов}

Функция расчета расходов более сложная, чем для дохода. Связано это с тем, что расходы
учитывают издержки хранения и продажи, а так же временную стоимость средств, вложенных
в закупку запасов. Вся совокупность описанных издержек \qu{сворачивается} в величине нормы
прибыли $r$.

За предельно малый промежуток времени $dt$, начинающийся с момента $t$ издержки составят:

$$
	dE = c \cdot D \cdot e^{rt} \cdot dt
$$

При интегрировании этой функции за период от $0$ до  $\frac{R}{D}$ получаем:

$$
	E = c \cdot D \cdot \int\limits_0^\frac{R}{D} e^{rt} dt
$$

Что в итоге дает:

$$
	E = c \cdot D \cdot \frac{e^{r\frac{R}{D}} - 1}{r}
$$

\subsection{Расчет оптимального объема запаса}

Функция $f(x) = I - E$ имеет экстремум (максимум). Дифференцируя ее и приравнивая нулю
результат мы можем получить выражение для вычисления оптимального размера запаса:

$$
	R_{opt} = \frac{D}{r}\ln{\frac{p}{c}}
$$

Заметим, что оптимальное значение на много выше того уровня запасов, который
обычно предприятия предпочитают содержать.

\ppyexample{
	Предположим, некоторый товар закупается по цене 16 рублей, а продается по 22 рубля.
	Средний ежедневный спрос на этот товар равен 7. При норме прибыли 50\% годовых
	оптимальный запас этого товара составит 1627 с небольшим единиц и этого запаса
	хватит более чем на 232 дня (едва ли какой-либо магазин или оптовый склад станет
	хранить столь большой объем одного товара хотя бы из-за высокой неопределенности спроса
	в такой временной перспективе).
}

В действительности, рассматриваемая модель не будет стремиться к оптимальному уровню
запасов для каждого товара поскольку ее цель - многопродуктовая оптимизация. То есть,
назначение модели - в нахождении оптимальной с точки зрения прибыльности комбинации множества
товаров с учетом ограничений.

\subsection{Первые результаты}

Уже из всего вышесказанного мы можем получить важные практические результаты. А именно,
наши выкладки для одного товара позволяют определить минимальную наценку на товар при заданном
спросе, либо найти минимальный ежедневный спрос, который необходим для достижения безубыточности
продаж товара, имеющего заданные цены закупа и продажи.

\paragraph{Минимальная наценка}

Величина наценки равна отношению цены продажи к цене закупа. Если наценка ниже минимальной,
то хранение и продажа товара становится не рентабельной.
Для вычисления минимальной наценки необходимо приравнять нулю доходность от одной упаковки товара.

В результате получаем следующее выражение:

$$
	\mu_{min} = \frac{D}{Pckg} \cdot \frac{e^{\frac{r \cdot Pckg}{D}}}{r}
$$

\paragraph{Минимальный спрос}

При заданном значении наценки бывает необходимо определить минимальный требуемый спрос на товара,
при котором рентабельность хранения и продажи еще не отрицательна.

\chapter{Проект SARTR}

Проект SARTR призван реализовать масштабную концепцию компьютерной обработки
естественных языков (NLP).

Важные отличительные черты проекта:

\begin{description}
	\item[Открытость]
	Проект реализуется по лицензии GPL. 
	
	\item[Поддержка любых натуральных языков]
	Предполагается возможность включения в систему словарей и правил для любых
	языков.
	
	\item[Компактность]
	Объемы программного кода и словарей должны быть достаточно малыми для того,
	чтобы функции, реализуемые системой могли быть легко включены в любые инсталлируемые
	приложения.

	\item[Универсальность]
	Система должна обеспечивать большинство утилитарных функций, требуемых приложениям
	общего назначения. Как то: 
	\begin{itemize}
		\item проверка орфографии и синтаксиса
		\item распознавание специфических плохо структурированных строк (адреса, имена, 
		новостные сообщения, наименования товаров и др.)
		\item лексическая трансформация небольших текстов (склонение имен, географических
		названий, общеупотребительных выражений и т.д.)
		\item переводы, и национальная локализация текстов.
	\end{itemize}
	
\end{description}

\section{Сущности}

\begin{itemize}
	\item Лексемы
	\item Трансформации
	\item Понятия (концепции)
	\item Связи
\end{itemize}

\subsection{Лексемы}

Лексемой будем называть устоявшееся слово либо часть слова. 
Кроме того, к лексемам отнесем общепринятые комбинации символов, имеющие
смысл кодов. Например: штрихкод, ip-адрес, почтовый индекс. Многие из этих
кодов в базе данных лексем не хранятся, но распознаются по строго определенным
правилам.

Структура хранения лексемы:

$LEXEM : LEX LEXID$

$LEX$ - текстовое представление лексемы в формате UNICODE

$LEXID$ - числовой идентификатор лексемы в формате беззнакового целого четырехбайтового числа (uint32).

Идентификаторы хранимых лексем не резервируются. То есть все особенности, семантика, правила
трансформации и прочие характеристики лексем определяются либо на основе правил, хранящихся в
базе данных в купе с алгоритмическими механизмами.

Вместе с тем небольшой диапазон идентификаторов резервируется для представления специализированных
лексем (индексы, штрихкоды и другие, которые могут быть алгоритмически идентифицированы с достаточной степенью
достоверности).

Список специализированных лексем:

\begin{description}
	\item[ip-address]
	\item[email-address]
	\item[URL]
	\item[barcode EAN13]
	\item[barcode EAN8]
	\item[barcode UPCA]
	\item[barcode UPCE]
	\item[ИНН (Россия)]
	\item[Почтовый индекс (Россия)]
\end{description}

\subsection{Трансформации}

Трансформация - это правило преобразования начальной формы слова в иную форму.
Например, спряжение глагола, склонение существительного и т.д.

\subsection{Связи}

Связи определяют следующие отношения:

\begin{description}
	\item[Лексема-Лексема] 
	\item[Лексема-Трансформация]
	\item[Лексема-Семантическая сущность]
\end{description}

Структура хранения связи:

$
	LEXLINK: 
		LEXID LEXID SEM
		LEXID 0     TRANSFORM
$

\section{Семантика}

Семантическую классификацию позаимствуем из библиотечных классификаторов.
Примеры есть на ресурсе http://www.innvista.com/society/education/info/classif.htm
Особенно интересны: Dewey Decimal Classification System (www-lib.nearnorth.edu.on.ca/dewey/ddc.htm)

\chapter{Протокол взаимодействия \ppybrand{} и оборудования}

\section{Введение}

Для взаимодействия устройства и \ppybrand{} в драйвере устройства должна быть реализована экспортируемая функция RunCommand (const char  *  pCmd, const char * pInputData, char * pOutputData, size\_t  outSize). В параметре pCmd передается команда в символьном виде, которую должно выполнить устройство. В pInputData -- параметры передаваемой команды. В главе \qu{Основные команды} описаны команды и параметры, которые должны поддерживать все устройства из данного руководства. Также отдельный класс устройств имеет свой набор команд и параметров, о чем подробнее написано в главе \qu{Команды для работы с устройствами}. Получив файл драйвера, необходимо сделать о нем запись в ini-файле каталога \ppybrand{}. Об это подробно написано в главе \qu{Завершающая стадия. Запись в ini-файл}.

\subsection{Экспортируемая функция}
	\paragraph{Синтаксис}
	\begin{description}
		\item[] RunCommand (const char  *  pCmd, const char * pInputData, char * pOutputData, size\_t  outSize)
	\end{description}
	\paragraph{Входные параметры (устанавливает \ppybrand{})}
	\begin{description}
		\item[pCmd]  Имя команды на выполнение.
		\item[pInputData] Перечень параметров, необходимых для выполнения команды. Параметры представляют собой 				пары	\qu{ПАРАМЕТР=значение}, разделенные \qu{\textbf;}.
		\item[outSize] Размер строки pOutputData.
	\end{description}
	\paragraph{Выходные параметры (устанавливает драйвер)}
	\begin{description}
		\item[pOutputData] Результат выполнения команды. Это может быть пустая строка, перечень возвращаемых 					параметров, код ошибки.
	\end{description}
	\paragraph{Возвращаемые значения}
	\begin{description}
		\item[0] Успешное выполнение команды.
		\item[1] Ошибка выполнения команды (в pOutputData передается код ошибки).
		\item[2]  Недостаточный размер выходного буфера pOutputData.
	\end{description}
	\paragraph{Коды ошибок, передаваемые в pOutputData (для некоторых классов устройств существуют дополнительные коды ошибок, которые перечислены в разделах описания этих классов)}
	\begin{description}
		\item[300] Не достаточно параметров для работы устройства.
		\item[301] Передана неизвестная команда.
		\item[302] Ошибка инициализации.
		\item[303] Соединение не установлено.
	\end{description}

\subsection{Порядок взаимодействия \ppybrand{} и устройства}
\paragraph{}На каждую посланную драйверу команду должен прийти ответ.
\paragraph{}Напрмер, \ppybrand{}  отправил команду на соединение
	\begin{description}
		\item[RunCommand («CONNECT», «PORT=1234», pOutputData, outSize).]
	\end{description}
В случае, если команда выполнена успешно, драйвер возвращает код возврата =0 и команду вида:
	\begin{description}
		\item[RunCommand («CONNECT», 0, 0, outSize).]
	\end{description}
Если же возникла ошибка, то драйвер возвращает код =1 и команду вида: 
	\begin{description}
		\item[RunCommand («CONNECT», 0, «303», outSize),]
	\end{description}
где 303 -- код ошибки. Если возникшая ошибка описана в данном руководстве, то передается указанный код. В противном случае, передается тот код, который описан в протоколе устройства.
\paragraph{}\ppybrand{} может запросить описание последней возникшей ошибки. Тогда он отправит команду вида:
	\begin{description}
		\item[RunCommand («GETLASTERRORTEXT», 0, pOutputData, outSize).]
	\end{description}
На это, исходя из предыдущего примера, драйвер ответит командой вида:
	\begin{description}
		\item[RunCommand («GETLASTERRORTEXT», 0, «Соединение не установлено», outSize).]
	\end{description}
Если размера буфера pOutputData, указанного в outSize, не хватает для передачи ответа, то драйвер возвращает код =2.

\section{Команды}

\subsubsection{ОБЩИЕ КОМАНДЫ}
	\begin{description}
		\item[INIT] Команда инициализации устройства. (стр.~\pageref{sub-init})
		\item[RELEASE] Освобождение устройства. Устройство обнуляет все параметры, которые были переданы ему на этапе 			инициализации. (стр.~\pageref{sub-release})
		\item[CONNECT] Команда на установку соединения с устройством. (стр.~\pageref{sub-connect})
		\item[DISCONNECT] Команда на закрытие соединения с устройством. (стр.~\pageref{sub-disconnect})
		\item[SETCONFIG] \ppybrand{} передает устройству пары \qu{ПАРАМЕТР=значение}. (стр.~\pageref{sub-setconfig})
		\item[GETCONFIG] \ppybrand{} запрашивает значения перечисленных параметров. (стр.~\pageref{sub-getconfig})
		\item[GETLASTERRORTEXT] \ppybrand{} запрашивает текст описания последней ошибки. (стр.~\pageref{sub-getlasterrortext})
	\end{description}

\subsubsection{ВЕСЫ}
	\begin{description}
		\item[SENDPLU] Загружает на весы информацию о товаре. (стр.~\pageref{sub-sub-scale-sendplu})
		\item[GETDATA] Получает данные с весов. (стр.~\pageref{sub-sub-scale-getdata})
	\end{description}

\subsubsection{СИНХРОННЫЕ КАССЫ}
	\begin{description}
		\item[CHECKSESSOVER] Проверка на то, что сессия длиться больше 24 часов. (стр.~\pageref{sub-sub-synccash-checksessover})
		\item[XREPORT] Печать X-отчета. (стр.~\pageref{sub-sub-synccash-xreport})
		\item[ZREPORT] Печать Z-отчета. (стр.~\pageref{sub-sub-synccash-zreport})
		\item[OPENBOX] Открыть денежный ящик. (стр.~\pageref{sub-sub-synccash-openbox})
		\item[OPENCHECK] Открыть чек. (стр.~\pageref{sub-sub-synccash-opencheck})
		\item[CLOSECHECK] Закрыть и распечатать чек. (стр.~\pageref{sub-sub-synccash-closecheck})
		\item[PRINTFISCAL] Печать фискальной строки. (стр.~\pageref{sub-sub-synccash-printfiscal})
		\item[PRINTTEXT] Печать текста. (стр.~\pageref{sub-sub-synccash-printtext})
		\item[ANNULATE] Аннулировать документ. (стр.~\pageref{sub-sub-synccash-annulate})
		\item[INCASHMENT] Внесение/изъятие наличности. (стр.~\pageref{sub-sub-synccash-incashment})
		\item[GETCHECKPARAM] Получить параметры текущего документа. (стр.~\pageref{sub-sub-synccash-getcheckparam})
		\item[CLEARSLIPBUF] Отчистить буфер подкладного документа. (стр.~\pageref{sub-sub-synccash-clearslipbuf})
		\item[FILLSLIPBUF] Заполнение буфера подкладного документа строками для печати. (стр.~\pageref{sub-sub-synccash-fillslipbuf})
		\item[PRINTSLIPDOC] Печать подкладного документа. (стр.~\pageref{sub-sub-synccash-printslipdoc})
		\item[GETECRSTATUS] Вернуть статус ККМ (состояние печатающего устройства). (стр.~\pageref{sub-sub-synccash-getecrstatus})
		\item[CONTINUEPRINT] Продолжить печать документа. (стр.~\pageref{sub-sub-synccash-continueprint})
	\end{description}

\subsubsection{PRICE CHECKERS}
	\begin{description}
		\item[SENDBARCODE] Устройство передает Papyrus штрихкод товара. (стр.~\pageref{sub-sub-pricecheckers-sendbarcode})
		\item[PRINTTEXT] Передает на устройство информацию о запрошенном товаре. (стр.~\pageref{sub-sub-pricecheckers-printtext})
		\item[NEXTLINE] Перевести курсор на следующую строку. (стр.~\pageref{sub-sub-pricecheckers-nextline})
		\item[CLEAR] Отчистить экран. (стр.~\pageref{sub-sub-pricecheckers-clear})
		\item[SETPIXELPOS] Установить начальную позицию пикселя текста. (стр.~\pageref{sub-sub-pricecheckers-setpixelpos})
		\item[SETCURSORPOS] Установить начальную позицию курсора. (стр.~\pageref{sub-sub-pricecheckers-setcursorpos})
	\end{description}

\subsubsection{ДИСПЛЕИ ПОКУПАТЕЛЕЙ}
	\begin{description}
		\item[PUTLINE] Вывести текст. При этом указанная строка сначала должна быть очищена самим устройством. 					(стр.~\pageref{sub-sub-customdisplay-putline})
		\item[CLEARDISPLAY] Очистить экран. (стр.~\pageref{sub-sub-customdisplay-cleardisplay})
	\end{description}

\section{Основные команды}

\subsection{INIT}\label{sub-init}
	Команда инициализации устройства.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} 
	\begin{description}
		\item[pOutputData] В случае успешного выполнения команды - пустая строка, иначе - код ошибки.
	\end{description}

\subsection{RELEASE}\label{sub-release}
Освобождение устройства. Устройство обнуляет все параметры, которые были переданы ему на этапе инициализации.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} 
	\begin{description}
		\item[pOutputData] В случае успешного выполнения команды - пустая строка, иначе - код ошибки.
	\end{description}

\subsection{CONNECT}\label{sub-connect}
Команда на установку соединения с устройством.
	\paragraph{Входные параметры}
	\begin{description}
		\item[pInputData] PORT и BAUDRATE (номер порта/IP-адрес и скорость обмена). В зависимости от того, к какому классу 			принадлежит устройстово, передается либо один параметр, либо два. Подробнее на стр.~\pageref{sub-sub-scale-connect}, \pageref{sub-sub-synccash-connect}, \pageref{sub-sub-pricecheckers-connect}, \pageref{sub-sub-customdisplay-connect}.
	\end{description}
	\paragraph{Выходные параметры} 
	\begin{description}
		\item[pOutputData] В случае успешного выполнения команды - пустая строка, иначе - код ошибки.
	\end{description}

\subsection{DISCONNECT}\label{sub-disconnect}
Команда на закрытие соединения с устройством.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} 
	\begin{description}
		\item[pOutputData] В случае успешного выполнения команды - пустая строка, иначе - код ошибки.
	\end{description}

\subsection{SETCONFIG}\label{sub-setconfig}
\ppybrand{} передает устройству пары \qu{ПАРАМЕТР=значение}, которые определены в системе и  соответствуют конкретному классу устройств. Если параметр драйверу устройства не известен, то драйвер пропускает его.
	\paragraph{Входные параметры}
	\begin{description}
		\item[pInputData] Зависит от конкретного класса устройств. Возможные параметры и их значения перечислены в 				разделах описания работы с конкретными устройствами. Подробнее на стр.~\pageref{sub-sub-scale-setconfig}, 					\pageref{sub-sub-synccash-setconfig}.
	\end{description}
	\paragraph{Выходные параметры} 
	\begin{description}
		\item[pOutputData] В случае успешного выполнения команды - пустая строка, иначе - код ошибки.
	\end{description}

\subsection{GETCONFIG}\label{sub-getconfig}
\ppybrand{} запрашивает значения параметров. На этот запрос драйвер должен вернуть все параметры, перечисленные в данном документе в разделе описания работы с данным классом устройств. Возвращаемые параметры перечисляются через \qu{\textbf;} в виде пар \qu{ПАРАМЕТР=значение}.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} 
	\begin{description}
		\item[pOutputData] В случае успешного выполнения команды пары \qu{ПАРАМЕТР=значение}, иначе - код ошибки. 				Возможные параметры и их значения перечислены в разделах описания работы с конкретными устройствами. 					Подробнее на стр.~\pageref{sub-sub-pricecheckers-getconfig}, \pageref{sub-sub-customdisplay-getconfig}.
	\end{description}

\subsection{GETLASTERRORTEXT}\label{sub-getlasterrortext}
\ppybrand{} запрашивает текст описания последней ошибки.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} 
	\begin{description}
		\item[pOutputData] Текст ошибки.
	\end{description}


\section{Команды для работы с устройствами}
\subsection{\huge{Весы}}
(Возможно, потребуются еще команды и параметры. Пока не совсем ясно где и какие параметры обязательны.)

\subsubsection{\Large{Параметры общих команд}}

\subsubsection{CONNECT}\label{sub-sub-scale-connect}
	\paragraph{Входные параметры}
	\begin{description}
		\item[PORT] (число/строка) Обязательный параметр. Номер COM-порта или IP-адрес.
		\item[BAUDRATE] (число) Обязательный параметр. Скорость обмена. Возможные значения смотри ниже.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра BAUDRATE}
	\begin{description}
		\item[0] Скорость обмена 2400 бод.
		\item[1] Скорость обмена 4800 бод.
		\item[2] Скорость обмена 9600 бод.
		\item[3] Скорость обмена 14400 бод.
		\item[4] Скорость обмена 19200 бод.
		\item[5] Скорость обмена 38400 бод.
		\item[6] Скорость обмена 56000 бод.
		\item[7] Скорость обмена 57600 бод.
		\item[8] Скорость обмена 115200 бод.
		\item[9] Скорость обмена 128000 бод.
		\item[10] Скорость обмена 256000 бод.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
		\item[] RunCommand («CONNECT», «PORT=1234;BAUDRATE=1», pOutputData, outSize)
		\end{description}
	}

\subsubsection{SETCONFIG}\label{sub-sub-scale-setconfig}
	\paragraph{Входные параметры}
	\begin{description}
		\item[LOGNUM]  (число) Обязательный параметр. Логический номер устройства.
		\item[PROTOCOLVER] (число) Обязательный параметр. Версия протокола обмена.
		\item[PREFIXBC] (число) Обязательный параметр. Префикс штрихкода.
		\item[STRIPWP] (число) Обязательный параметр. Игнорировать весовой префикс. Возможные значения смотри ниже.
		\item[READNUMTRIES] (число) Обязательный параметр. Количество попыток чтения из порта.
		\item[READNUMDELAY] (число) Обязательный параметр. Задержка между попытками чтения из порта (мс).
		\item[WRITENUMTRIES] (число) Обязательный параметр. Количество попыток записи в порт.
		\item[WRITENUMDELAY] (число) Обязательный параметр. Задержка между попытками записи в порт (мс).
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра STRIPWP}
	\begin{description}
		\item[0] Не игнорировать префикс.
		\item[1] Игнорировать префикс.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
		\item[] RunCommand («SETCONFIG», «LOGNUM=1; PROTOCOLVER=20; PREFIXBC=7;
		STRIPWP=0; READNUMTRIES=400; READNUMDELAY=5; WRITENUMTRIES=400; 
		WRITENUMDELAY=5», pOutputData, outSize)
		\end{description}
	}

\subsubsection{\Large{Дополнительные команды}}

\subsubsection{SENDPLU}\label{sub-sub-scale-sendplu}
	Загружает на весы информацию о товаре.
	\paragraph{Входные параметры}
	\begin{description}
		\item[GOODNUMBER] (число) Обязательный параметр. Номер товара.
		\item[GROUPCODE] (число) Обязательный параметр. Номер группы товаров.
		\item[GOODNAME] (строка) Обязательный параметр. Наименование товара. (кодировка CP886)
		\item[PRICE] (число) Обязательный параметр. Цена реализации товара в копейках.
		\item[EXPIRY] (строка) Обязательный параметр. Дата окончания срока годности в формате дд.мм.гг.
		\item[BARCODE] (число) Обязательный параметр. Штрихкод.
		\item[ADDMESSAGE] (строка) Необязательный параметр. Дополнительная информация о товаре. (кодировка CP886)
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («SENDPLU», «GOODNUMBER=12; GROUPCODE=1; GOODNAME=Конфеты 									"Белочка"; PRICE=6400; EXPIRY=12.12.12; BARCODE=123456789», pOutputData, outSize)
		\end{description}
	}

\subsubsection{GETDATA}\label{sub-sub-scale-getdata}
	Получает данные с весов.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры}
	\begin{description}
		\item[GOODNUMBER] (число) Обязательный параметр. Номер товара.
		\item[WEIGHT] (число) Обязательный параметр. Вес товара в граммах.
	\end{description}
	\ppyexample{
		\paragraph{ Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («GETDATA», 0, pOutputData, outSize)
		\end{description}
		\paragraph{Драйвер отвечает:}
		\begin{description}
			\item[] RunCommand («GETDATA», 0, «GOODNUMBER=12; WEIGHT=450», outSize)
		\end{description}
	}

\paragraph{}
\paragraph{}

\subsection{\huge{Синхронные кассы}}

\subsubsection{\Large{Параметры общих команд}}

\subsubsection{CONNECT}\label{sub-sub-synccash-connect}
	\paragraph{Входные параметры}
	\begin{description}
		\item[PORT] (число) Обязательный параметр. Номер COM-порта.
		\item[BAUDRATE] (число) Обязательный параметр. Скорость обмена. Возможные значения смотри ниже.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра BAUDRATE}
	\begin{description}
		\item[0] Скорость обмена 2400 бод.
		\item[1] Скорость обмена 4800 бод.
		\item[2] Скорость обмена 9600 бод.
		\item[3] Скорость обмена 14400 бод.
		\item[4] Скорость обмена 19200 бод.
		\item[5] Скорость обмена 38400 бод.
		\item[6] Скорость обмена 56000 бод.
		\item[7] Скорость обмена 57600 бод.
		\item[8] Скорость обмена 115200 бод.
		\item[9] Скорость обмена 128000 бод.
		\item[10] Скорость обмена 256000 бод.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CONNECT», «PORT=1234; BAUDRATE=1», pOutputData, outSize)
		\end{description}
	}

\subsubsection{SETCONFIG}\label{sub-sub-synccash-setconfig}
	\paragraph{Входные параметры}
	\begin{description}
		\item[LOGNUM] (число) Обязательный параметр. Логический номер устройства.
		\item[AUTOCASHNULL] (число) Обязательный параметр. Автоматическое обнуление наличности. Возможные значения 				смотри ниже.
		\item[SESSIONID] (число) Обязательный параметр. Номер текущей сессии.
		\item[CSHRNAME] (строка) Обязательный параметр. Имя кассира. (кодировка CP886)
		\item[ADMINNAME] (строка) Обязательный параметр. Имя администратора. (кодировка CP886)
		\item[ADMINPASSWORD] (строка) Обязательный параметр. Пароль администратора. (кодировка CP886)
		\item[FLAGS] (число) Обязательный параметр. Флаги. Передаются в десятичном виде. Возможные значения смотри 				ниже.
		\item[PRINTLOGO] (число) Обязательный параметр. Печатать логотип. Возможные значения смотри ниже.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра AUTOCASHNULL}
	\begin{description}
		\item[0] Не обнулять.
		\item[1] Обнулять.
	\end{description}
	\paragraph{Значения параметра FLAGS}
	\begin{description}
		\item[0x00000008] Не активировать первую строку чека.
		\item[0x00000010] Открывать денежный ящик при пробивке чека.
		\item[0x00000100] Округлять в чеке \% скидки до целого.
		\item[0x08000000] Не использовать отрезчик чеков.
	\end{description}
	\paragraph{Значения параметра PRINTLOGO}
	\begin{description}
		\item[0] Не печатать логотип на документах.
		\item[1] Печатать логотип.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («SETCONFIG», «LOGNUM=1; SESSIONID=2; AUTOCASHNULL=1;  									CSHRNAME=Кассир; ADMINNAME=Старший кассир; ADMINPASSWORD=Пароль; 
			FLAGS=24; PRINTLOGO=0», pOutputData, outSize)
		\end{description}
	}

\subsubsection{\Large{Дополнительные команды}}

\subsubsection{CHECKSESSOVER}\label{sub-sub-synccash-checksessover}
	Проверка на то, что сессия длиться больше 24 часов.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры}
	\begin{description}
		\item[0] Cессия длится меньше 24 часов.
		\item[1] Cессия длится больше 24 часов.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CHECKSESSOVER», 0, pOutputData, outSize)
		\end{description}
		\paragraph{Драйвер отвечает:}
		\begin{description}
			\item[] RunCommand («CHECKSESSOVER», 0, «0» (или «1»), outSize)
		\end{description}
	}

\subsubsection{XREPORT}\label{sub-sub-synccash-xreport}
	Печать X-отчета.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («XREPORT», 0, pOutputData, outSize)
		\end{description}
	}

\subsubsection{ZREPORT}\label{sub-sub-synccash-zreport}
	Печать Z-отчета.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («ZREPORT», 0, pOutputData, outSize)
		\end{description}
	}

\subsubsection{OPENBOX}\label{sub-sub-synccash-openbox}
	Открыть денежный ящик.
	\paragraph{Входные параметры}
	\begin{description}
 		\item[DRAWERNUM] (число) Обязательный параметр. Номер денежного ящика.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
 			\item[] RunCommand («OPENBOX», «DRAWERNUM=1», pOutputData, outSize)
		\end{description}
	}

\subsubsection{OPENCHECK}\label{sub-sub-synccash-opencheck}
	Открыть чек.
	\paragraph{Входные параметры}
	\begin{description}
 		\item[CHECKTYPE] (число) Обязательный параметр. Тип документа. Возможные значения смотри ниже.
 		\item[CHECKNUM] (число) Обязательный параметр. Текущий номер документа.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра CHECKTYPE}
	\begin{description}
 		\item[0] Сервисный.
 		\item[1] Чек на продажу.
 		\item[2] Чек на возврат.
 		\item[3] Внесение в кассу.
 		\item[4] Изъятие наличности.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («OPENCHECK», «CHECKTYPE=1; CHECKNUM=12», pOutputData, outSize)
		\end{description}
	}

\subsubsection{CLOSECHECK}\label{sub-sub-synccash-closecheck}
	Закрыть и распечатать чек.
	\paragraph{Входные параметры}
	\begin{description}
 		\item[PAYMCASH] (число) Сумма наличных, принятая от покупателя в рублях (при этом количество знаков после 				десятичной точки может быть любым).
		\item[PAYMCARD] (число) Сумма по карте, принятая от покупателя в рублях (при этом количество знаков после 				десятичной точки может быть любым).
	\end{description}
	Обязательно использование хотя бы одного параметра. В случае, если оплата произведена и по карте и наличными, то 			передаются оба параметра.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CLOSECHECK», «PAYMCASH=10.5», pOutputData, outSize)
		\end{description}
	}

\subsubsection{PRINTFISCAL}\label{sub-sub-synccash-printfiscal}
	Печать фискальной строки.
	\paragraph{Входные параметры}
	\begin{description}
 		\item[RIBBONPARAM] (число) Обязательный параметр. На какой носитель печатать. Возможные значения смотри ниже.
		\item[DEPARTMENT]  (число) Обязательный параметр. Номер отдела.
		\item[QUANTITY] (число) Обязательный параметр. Количество товара в товарной позиции.
		\item[PRICE] (число) Обязательный параметр. Цена реализации товара в рублях (при этом количество знаков после 				десятичной точки может быть любым).
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра RIBBONPARAM}
	\begin{description}
 		\item[0] Чековая лента.
 		\item[1] Контрольная чековая лента.
 		\item[2] Фискальная память.
 		\item[3] Подкладной документ.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («PRINTFISCAL», «RIBBONPARAM=0; DEPARTMENT=1; QUANTITY=5; PRICE=10», pOutputData, 				outSize)
		\end{description}
	}

\subsubsection{PRINTTEXT}\label{sub-sub-synccash-printtext}
	Печать текста.
	\paragraph{Входные параметры}
	\begin{description}
 		\item[RIBBONPARAM] (число) Обязательный параметр. На какой носитель печатать. Возможные значения смотри ниже.
 		\item[TEXT] (строка) Обязательный параметр. Строка, которую нужно напечатать. (кодировка CP886)
 		\item[FONTSIZE] (число) Обязательный параметр. Номер шрифта. Возможные значения смотри ниже.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра RIBBONPARAM}
	\begin{description}
 		\item[0] Чековая лента.
 		\item[1] Контрольная чековая лента.
 		\item[2] Фискальная память.
 		\item[3] Подкладной документ.
	\end{description}
	\paragraph{Значения параметра FONTSIZE}
	\begin{description}
 		\item[1] Очень мелкий.
 		\item[2] Мелкий.
 		\item[3] Средний.
 		\item[4] Крупный.
 		\item[5] Очень крупный.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («PRINTTEXT», «RIBBONPARAM=0; TEXT="Скидка 5\%"; FONTSIZE=3», pOutputData, outSize)
		\end{description}
	}

\subsubsection{ANNULATE}\label{sub-sub-synccash-annulate}
	Аннулировать документ.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («ANNULATE», 0, pOutputData, outSize)
		\end{description}
	}

\subsubsection{INCASHMENT}\label{sub-sub-synccash-incashment}
	Внесение/изъятие наличности.
	\paragraph{Входные параметры}
	\begin{description}
 		\item[AMOUNT] (число)  Обязательный параметр. Сумма изъятия/внесения в рублях (при этом количество знаков после 			десятичной точки может быть любым).
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («INCASHMENT», «AMOUNT=5000.55»,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{GETCHECKPARAM}\label{sub-sub-synccash-getcheckparam}
	Получить параметры текущего документа.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} 
	\begin{description}
 		\item[CASHAMOUNT] (число) Обязательный параметр. Сумма наличности в кассе в рублях (при этом количество знаков 			после десятичной точки может быть любым).
 		\item[RIBBONPARAM] (число) Обязательный параметр. Какой носитель выбран для печати. Возможные значения смотри 		ниже.
 		\item[CHECKNUM] (число) Обязательный параметр. Текущий номер документа.
	\end{description}
	\paragraph{Значения параметра RIBBONPARAM} 
	\begin{description}
 		\item[0] Чековая лента.
 		\item[1] Контрольная чековая лента.
 		\item[2] Фискальная память.
 		\item[3] Подкладной документ.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («GETCHECKPARAM», 0,  pOutputData, outSize)
		\end{description}
		\paragraph{Драйвер отвечает:}
		\begin{description}
			\item[] RunCommand («GETCHECKPARAM», «CASHAMOUNT=55.25; RIBBONPARAM=0; CHECKNUM=1»,  pOutputData, 				outSize)
		\end{description}
	}

\subsubsection{CLEARSLIPBUF}\label{sub-sub-synccash-clearslipbuf}
	Отчистить буфер подкладного документа.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CLEARSLIPBUF», 0,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{FILLSLIPBUF}\label{sub-sub-synccash-fillslipbuf}
	Заполнение буфера подкладного документа строками для печати.
	\paragraph{Входные параметры} 
	\begin{description}
 		\item[STRNUM] (число)  Обязательный параметр. Номер строки подкладного документа.
 		\item[TEXT] (строка) Обязательный параметр. Строка, которую нужно напечатать. (кодировка CP886)
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («FILLSLIPBUF», «STRNUM=1; TEXT=Печать документа»,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{PRINTSLIPDOC}\label{sub-sub-synccash-printslipdoc}
	Печать подкладного документа.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («PRINTSLIPDOC», 0,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{GETECRSTATUS}\label{sub-sub-synccash-getecrstatus}
	Вернуть статус ККМ (состояние печатающего устройства).
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры}
	\begin{description}
 		\item[STATUS] (число) Обязательный параметр. Флаг статуса ККМ. Передается в десятичном формате. Возможные 				значения сморти ниже.
	\end{description}
	\paragraph{Значения параметра STATUS}
	\begin{description}
 		\item[0x00] Нет печати.
 		\item[0x01] Нет бумаги.
 		\item[0x02] Ожидание команды на продолжение печати.
 		\item[0x04] Режим печати.
 		\item[0x08] Открыт чек.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («GETECRSTATUS», 0,  pOutputData, outSize)
		\end{description}
		\paragraph{Драйвер отвечает:}
		\begin{description}
			\item[] RunCommand («GETECRSTATUS», «STATUS=9»,  pOutputData, outSize)
		\end{description}
		\begin{description}
			\item[STATUS=9] Значит, что открыт чек и в принтере нет бумаги.
		\end{description}
	}

\subsubsection{CONTINUEPRINT}\label{sub-sub-synccash-continueprint}
	Продолжить печать документа.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CONTINUEPRINT», 0,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{Дополнительные коды ошибок}
	Ниже перечислены специфические ошибки, коды которых должен знать драйвер. В случае возникновения, код ошибки 			передается в pOutputData.
	\begin{description}
 		\item[400] Буфер подкладного документа пуст.
 		\item[401] Некорректное состояние ЭКЛЗ.
 		\item[402] ЭКЛЗ или ФП переполнена.
 		\item[403] Ошибка ЭКЛЗ. Просьба обратиться в ЦТО.
	\end{description}

\paragraph{}
\paragraph{}

\subsection{\huge{Price Checkers}}

\subsubsection{\Large{Основные команды}}

\subsubsection{CONNECT}\label{sub-sub-pricecheckers-connect}
	\paragraph{Входные параметры} 
	\begin{description}
		\item[PORT] (строка) Обязательный параметр. IP-адрес.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CONNECT», «PORT=127.0.0.1»,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{GETCONFIG}\label{sub-sub-pricecheckers-getconfig}
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры}
	\begin{description}
		\item[DISPLAYWIDTH] (число) Обязательный параметр. Ширина дисплея в пикселях.
		\item[DISPLAYHEIGHT] (число) Обязательный параметр.  Высота дисплея в пикселях.
		\item[LINECOUNT] (число) Обязательный параметр. Число строк, которое можно вывести на дисплей.
		\item[SYMBCOUNT] (число) Обязательный параметр. Количество символов в строке.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («GETCONFIG», 0,  pOutputData, outSize)
		\end{description}
		\paragraph{Драйвер отвечает:}
		\begin{description}
			\item[] RunCommand («GETCONFIG», «DISPLAYWIDTH=200; DISPLAYHEIGHT=50; LINECOUNT=2; SYMBCOUNT=20», 				pOutputData, outSize)
		\end{description}
	}

\subsubsection{\Large{Дополнительные команды}}

\subsubsection{SENDBARCODE}\label{sub-sub-pricecheckers-sendbarcode}
	Устройство передает \ppybrand{} штрихкод товара. После установки соединения \ppybrand{} будет ожидать эту команду.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры}
	\begin{description}
		\item[BARCODE] (число) Обязательный параметр. Штрихкод товара.
	\end{description}
	\ppyexample{
		\paragraph{Драйвер посылает:}
		\begin{description}
			\item[] RunCommand («SENDBARCODE», 0,  «BARCODE=132456789», outSize)
		\end{description}
	}

\subsubsection{PRINTTEXT}\label{sub-sub-pricecheckers-printtext}
	Передает на устройство информацию о запрошенном товаре.
	\paragraph{Входные параметры} 
	\begin{description}
		\item[TEXT] (строка) Обязательный параметр. Текст, описывающий товар. (кодировка CP886)
		\item[ALIGN] (число) Обязательный параметр. Выравнивание текста. Возможные значения смотри ниже.
		\item[FONT] (число) Обязательный параметр. Номер шрифта. Возможные значения смотри ниже.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра ALIGN} 
	\begin{description}
		\item[1] Слева вверху.
		\item[2] По центру вверху.
		\item[3] Справа вверху.
		\item[4] Слева по центру.
		\item[5] По центру.
		\item[6] Справа по центру.
		\item[7] Слева снизу.
		\item[8] Слева по центру.
		\item[9] Справа снизу.
		\item[10] Слева на текущей строке.
		\item[11] По центру на текущей строке.
		\item[12] Справа на текущей строке.
		\item[13] Сверху на текущей X-координате.
		\item[14] По центру на текущей X-координате.
		\item[15] Снизу на текущей X-координате.
		\item[16] Текущая позиция.
	\end{description}
	\paragraph{Значения параметра FONT} 
	\begin{description}
		\item[1] Очень мелкий.
		\item[2] Мелкий.
		\item[3] Средний.
		\item[4] Крупный.
		\item[5] Очень крупный.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («PRINTTEXT», «TEXT=Кофеты "Лакомка" ВЕС 200 гр; ALIGN=0; FONT=1»,  pOutputData, 					outSize)
		\end{description}
	}

\subsubsection{NEXTLINE}\label{sub-sub-pricecheckers-nextline}
	Перевести курсор на начало следующей строки.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («NEXTLINE», 0,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{CLEAR}\label{sub-sub-pricecheckers-clear}
	Отчистить экран.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CLEAR», 0,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{SETPIXELPOS}\label{sub-sub-pricecheckers-setpixelpos}
	Установить позицию пикселя текста.
	\paragraph{Входные параметры} 
	\begin{description}
		\item[XCOORD] (число) Обязательный параметр. Номер пикселя по горизонтали.
		\item[YCOORD] (число) Обязательный параметр. Номер пикселя по вертикали.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («SETPIXELPOS», «XCOORD=20; YCOORD=1»,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{SETCURSORPOS}\label{sub-sub-pricecheckers-setcursorpos}
	Установить позицию курсора.
	\paragraph{Входные параметры} 
	\begin{description}
		\item[XCOORD] (число) Обязательный параметр. Номер позиции в строке.
		\item[YCOORD] (число) Обязательный параметр. Номер строки.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («SETCURSORPOS», «XCOORD=20; YCOORD=1»,  pOutputData, outSize)
		\end{description}		
	}

\paragraph{}
\paragraph{}

\subsection{\huge{Дисплеи покупателей}}

\subsubsection{\Large{Основные команды}}

\subsubsection{CONNECT}\label{sub-sub-customdisplay-connect}
	\paragraph{Входные параметры} 
	\begin{description}
		\item[PORT] (число) Обязательный параметр. Номер COM-порта.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CONNECT», «PORT=1234»,  pOutputData, outSize)
		\end{description}
	}

\subsubsection{GETCONFIG}\label{sub-sub-customdisplay-getconfig}
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры}
	\begin{description}
		\item[STRLEN] (число) Обязательный параметр. Ширина строки в символах.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («GETCONFIG», 0,  pOutputData, outSize)
		\end{description}
		\paragraph{Драйвер отвечает:}
		\begin{description}
			\item[] RunCommand («GETCONFIG», «STRLEN=20», pOutputData, outSize)
		\end{description}
	}

\subsubsection{\Large{Дополнительные команды}}

\subsubsection{PUTLINE}\label{sub-sub-customdisplay-putline}
	Вывести текст. При этом указанная строка сначала должна быть очищена самим устройством.
	\paragraph{Входные параметры} 
	\begin{description}
		\item[TEXT] (строка) Обязательный параметр. Текст для вывода на экран. (кодировка CP886)
		\item[VERTAB] (число) Обязательный параметр. Переместить курсор по вертикали. Возможные значения смотри ниже.
		\item[ALIGN ] (число) Обязательный параметр. Выравнивание по горизонтали. Возможные значения смотри ниже.
	\end{description}
	\paragraph{Выходные параметры} Отсутствуют.
	\paragraph{Значения параметра VERTAB} 
	\begin{description}
		\item[0] На строку вверх.
		\item[1] На строку вниз.
		\item[2] Текущая позиция.
	\end{description}
	\paragraph{Значения параметра ALIGN} 
	\begin{description}
		\item[0] Cлева.
		\item[1] Cправа.
		\item[2] По центру.
		\item[3] Текущая позиция.
	\end{description}
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («PUTLINE», «TEXT=Конфеты "Лакомка"; VERTAB=3; ALIGN=1», pOutputData, outSize)
		\end{description}
	}

\subsubsection{CLEARDISPLAY}\label{sub-sub-customdisplay-cleardisplay}
	Очистить экран.
	\paragraph{Входные параметры} Отсутствуют.
	\paragraph{Выходные параметры} Отсутствуют.
	\ppyexample{
		\paragraph{Papyrus посылает:}
		\begin{description}
			\item[] RunCommand («CLEARDISPLAY», 0, pOutputData, outSize)
		\end{description}
	}

\section{Завершающая стадия. Запись в ini-файл}
Получив файл драйвера устройства с экспортируемой функцией RunCommand(), необходимо поместить его в каталог PPY/BIN/DRV/ и отметить в файле ppdrv.ini, который находится в каталоге PPY/BIN/. Формат записи следующий:
\begin{description}
	\item[идентификатор=имя\_для\_отображения,тип\_файла\_драйвера,имя\_файла\_с\_расширением]
\end{description}
Между элементами записи не должно быть пробелов.
\paragraph{}Запись нужно сделать в соответствующей группе устройств. Название группы написано в квадратных скобках. Пояснение к названиям смотри ниже.
\paragraph{}К примеру, так запись будет выглядеть для dll-файла синхронной ККМ \qu{ПИРИТ}:
	\ppyexample{
		\paragraph{} [SyncPOS]
		\paragraph{} ...
		\paragraph{} pirit-petrogl=DRV:Пирит (Петроглиф),dll,Pirit.dll
		\paragraph{} ...
	}
В примере:
\begin{description}
	\item[SyncPOS] Запись сделана в  группе устройств \qu{синхронные ККМ}.
	\item[pirit-petrogl] Идентификатор.
	\item[DRV:Пирит (Петроглиф)] Строка, которая будет отображаться в \ppybrand{} для идентификации устройства.
	\item[dll] Тип файла драйвера.
	\item[Pirit.dll] Имя файла драйвера с расширением.
\end{description}
\paragraph{Группы устройств}
\begin{description}
	\item[SyncPOS] Синхронные ККМ.
	\item[AsyncPOS] Асинхронные ККМ.
	\item[Scale] Весы.
	\item[CustomDisplay] Дисплеи покупателей.
\end{description}

\chapter{Зарезервированные объекты}

\section{Universe-HTT}

Глобальная учетная запись администрирования устройств Stylo на Universe-HTT: stylo-common@uhtt.ru eMiKi5G66ah-AZB

\subsection{Необходимые настройки в базе данных Papyrus на сервере Universe-HTT}

\paragraph{Товары и товарные группы}

Товарная группа \ppyrsrv{Special Items}: наименование не важно, код не важен. В эту группу заносятся товары, необходимые для функционирования сервера.

Тарифицирующие товары группы \ppyrsrv{Special Items} необходимы для идентификации стоимости тарификации той или иной клиентской операции.
В этих товарах важен код. Формат кода: GTA[0-9]+.

\begin{description}
	\item[GTA001] \ppyrsrv{Gta objget}. Общий тариф доступа к объектам данных. Фактически не используется. Для регламентации стоимости
	доступа к конкретным типам объектов необходим товар с кодом GTA001[OBJTYPEID] где OBJTYPEID - идентификатор типа объекта.
	Например, для тарификации доступа к товарам применяется специальный товар GTA0011009
	
\end{description}

\paragraph{Персональные отношения}

\begin{description}
	\item[Управляющая персоналия] Символ \ppyrsrv{UHTT\_PSNREL\_MASTER}. Определяет отношение от персоналии - владельца аккаунта к поставщикам.
\end{description}

\chapter{Регламентированные задания}
	\paragraph{Проверка работоспособности}
		\begin{enumerate}
			\item petroglif.ru
			\item uhtt.ru
			\item forum.petroglif.ru
			\item papyrus
		\end{enumerate}
		\begin{description}	
		\item Отчёт о проверке: \verb|D:\Papyrus\Src\Doc\TasksReport.xlsx|
	\end{description}


\chapter{Установка и настройка внешних компонентов}

\section{Установка Rabbit MQ}

Брокер сообщений Rabbit-MQ используется для перспективный разработок в рамках проектов Papyrus и
Stylo-Q.

Здесь я оставляю инструкцию по нюансам установки Rabbit-MQ на сервере.

В общем, порядок установки такой: 
\begin{enumerate}
	\item Скачиваем и ставим Erlang.
	\item Скачиваем и ставим Rabbit-MQ. В процесс установки придется вмешаться по причинам, которые будут раскрыты ниже.
	\item Делаем некоторые настройки для того, что бы все это работало.
\end{enumerate}

\subsection{Установка Erlang/OT}

Домашний сайт Erlang: https://www.erlang.org

Установка Erlang/OT простая и не требует каких-либо специальных действий.

\subsection{Установка Rabbit-MQ}

Домашний сайт продукта: www.rabbitmq.com

Я буду исходить из варианта установки путем запуска Windows-дистрибутива.
Путь для инсталляции укажите 

Здесь же можно скачать дистрибутив.

\subsection{Настройка}

\end{document}